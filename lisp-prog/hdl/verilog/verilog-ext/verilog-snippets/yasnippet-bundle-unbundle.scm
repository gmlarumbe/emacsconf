#!/usr/bin/guile
!#

(define (yas/define-snippets mode-sym snippets-list unused)
  (let ((mode-name (symbol->string mode-sym)))
    (if (not (file-exists? mode-name))
        (mkdir mode-name))
    (let loop ((snippets-list snippets-list))
      (if (null? snippets-list) #t
          (let* ((snippet (car snippets-list))
                 (snippet-name (car snippet))
                 (snippet-string (cadr snippet)))
            (begin
              (with-output-to-file (string-append mode-name "/" snippet-name)
                (lambda () (display snippet-string)))
              (loop (cdr snippets-list))))))))

;;; yasnippet-bundle.el --- Yet another snippet extension (Auto compiled bundle)
;;; Yasnippet.el --- Yet another snippet extension for Emacs.

;; Copyright 2008 pluskid
;;           2009 pluskid, joaotavora
;; Copyright 2009 Verilog Snippets Added by Puneet Goel

;; Authors: pluskid <pluskid@gmail.com>, joaotavora <joaotavora@gmail.com>
;; Authors: Verilog Snippets: puneet <sv-snippets@coverify.org>
;; Version: 0.7.0
;; Package-version: 0.7.0
;; verilog-snippets-version: 0.2.0
;; X-URL: http://code.google.com/p/yasnippet/
;; Keywords: convenience, emulation
;; URL: http://code.google.com/p/yasnippet/
;; EmacsWiki: YaSnippetMode

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; Below is the cut from yasnippet-bundle.el
;; Original file you can find here: http://coverification.org/download/yasnippet-bundle.el.gz

(yas/define-snippets 'verilog-mode
                     '(("always" "always @(${1:posedge clk}) begin\n   $0\nend\n" "always @ .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("always" "always_comb begin\n   $0\nend\n" "always_comb .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("always" "always_ff @(${1:posedge clk or reset == 1})\n   $0\nend\n" "always_ff .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("always" "always_latch\n   $0\nend\n" "always_latch .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("always_comb" "always_comb begin\n   $0\nend\n" "always_comb .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("always_ff" "always_ff @(${1:posedge clk or reset == 1})\n   $0\nend\n" "always_ff .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("always_latch" "always_latch\n   $0\nend\n" "always_latch .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("case" "case(${1:expression})\n  ${2:value1}: begin\n     $0\n  end // case: $2\n\n  // other case branches\n\n  default: begin\n\n  end\nendcase // case($1)  \n\n" "case() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("case" "casex(${1:expression})\n  ${2:value1}: begin\n     $0\n  end // casex: $2\n\n  // other case branches\n\n  default: begin\n\n  end\nendcase // case($1)  \n\n" "casex() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("case" "casez(${1:expression})\n  ${2:value1}: begin\n     $0\n  end // casez: $2\n\n  // other case branches\n\n  default: begin\n\n  end\nendcase // case($1)  \n\n" "casez() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("casex" "casex(${1:expression})\n  ${2:value1}: begin\n     $0\n  end // casex: $2\n\n  // other case branches\n\n  default: begin\n\n  end\nendcase // case($1)  \n\n" "casex() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("casez" "casez(${1:expression})\n  ${2:value1}: begin\n     $0\n  end // casez: $2\n\n  // other case branches\n\n  default: begin\n\n  end\nendcase // case($1)  \n\n" "casez() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("class" "class ${1:class_name} extends ${2:base_class};\n   $0\n   function new(${3:args});\n      super.new($3);\n\n   endfunction: new\n\nendclass: $1\n" "class .. endclass" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("clocking" "clocking ${1:name_cb} @(posedge ${2:clock});\n   default input #${3:setup_time} output #${4:hold_time};\n   $0\n   // output declarations\n   // input declarations\nendclocking: $1\n" "clocking .. { .. }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("do" "do begin\n   $0\nend while($1);\n\n\n" "do .. while()" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("enum" "typedef enum {$0\n        } ${1:name_e};\n" "enum .. { .. }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("final" "final begin\n   $0\nend\n" "final .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("for" "for(${1:int i=0}; ${2:i!=n}; ++i) begin\n   $0\nend\n" "for() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("foreach" "foreach(${1:x}[i]) begin\n   $0\nend\n" "foreach(x[i]) .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("forever" "forever begin\n   $0\nend\n" "forever .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("fork" "fork\n   begin\n      $0\n   end\n   begin\n\n   end\njoin\n" "fork .. join" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("fork" "fork\n   begin\n      $0\n   end\n   begin\n\n   end\njoin_any\n" "fork .. join_any" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("fork" "fork\n   begin\n      $0\n   end\n   begin\n\n   end\njoin_none\n" "fork .. join_none" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("function" "function ${1:void} ${2:function_name} ($3);\n  $0\nendfunction: $2\n" "function .. endfunction" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("if" "if(${1:condition}) begin\n   $0\nend // if($1)\n\n" "if() .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("initial" "initial begin\n   $0\nend\n" "initial .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("interface" "// vmm rule 4-4 -- interfaces shall be packaged into the same files as the\n// transactors that use them\ninterface ${1:name_if} (// input wire clk,\n          // input wire reset\n           );\n   timeunit 1ns;\n   timeprecision 100ps;\n\n   $0\n   // imports\n   // import pkg::*;\n\n   // vmm rule 4-6 All interface signals shall be declared as wires.\n   // In some circumstances, more appropriate to use logic declarations.\n   // wire definitions -- do not specify as inputs and outputs\n   // keep that for modports\n\n   // vmm rule 4-8 -- setup and hold time in clocking blocks shall be defined\n   // using parameters.\n   parameter hold_time = 2;     // timeunit is 1ns\n   parameter setup_time = 2;    // change timing values as per requirement\n\n   // Clocking Blocks\n   // vmm rule 4-7 -- synchronous interface signals shall be sampled and driven\n   // using clocking block\n   // vmm rule 4-11 -- The direction of synchronous signals shall be specified\n   // in the clocking block declaration.\n   // just type clocking and tab for invoking snippet :)\n\n   // Modports\n   // vmm rule 4-9 -- Individual modports shall be declared for each type of\n   // proactive, reactive and passive transactors.\n   // vmm rule 4-10 -- The direction of asynchronous signals shall be shall be\n   // specified in the modport declaration.\n   // vmm rule 4-12 -- The clocking block shall be included in modports port\n   // list instead of individual clock and synchronous signals.\n   // just type modport and tab for invoking snippet :)\n\nendinterface: $1\n" "interface .. { .. }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("interface" "interface $1(input logic clock, input logic reset);\n\n   // ToDo: Declare the interface signals corresponding to the ports\n$0   wire [7:0] sync_tx;\n   wire [7:0] sync_rx;\n\n   logic async_sig;\n   \n   // ToDo: Define clocking blocks\n   // -- use the 'clocking' snippet\n   \n   // ToDo: Define a modport for each interface perspective\n   // -- use the 'modport' snippet\n\nendinterface: $1\n" "OVM Interface" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("interface" "//\n// Template for VMM-compliant interface\n//\n// ${1:IF}        Name of physical bus\n//\n\n\\`include \"vmm.sv\"\n\n\n// ToDo: One clock per clock domain\n\ninterface $1(input bit ck1,\n      input bit ck2);\n\n   // ToDo: Define default setup & hold times\n   $0\n   parameter setup_time = 5/*ns*/;\n   parameter hold_time  = 3/*ns*/;\n\n   // ToDo: Define synchronous and asynchronous signals as wires\n\n   wire [15:0] sync_txd;\n   wire [15:0] sync_rxd;\n   wire [15:0] sync_dat;\n\n   logic       async_en;\n   logic       async_rdy;\n\n\n   // ToDo: Define one clocking block per clock domain\n   //       with synchronous signal direction from a\n   //       master perspective\n\n   clocking mck1 @(posedge ck1);\n      default input #setup_time output #hold_time;\n      output sync_txd;\n      inout  sync_dat;\n   endclocking: mck1\n\n   clocking mck2 @(posedge ck2);\n      default input #setup_time output #hold_time;\n      input sync_rxd;\n   endclocking: mck2\n\n\n   // ToDo: Define one clocking block per clock domain\n   //       with synchronous signal direction from a\n   //       slave perspective\n\n   clocking sck1 @(posedge ck1);\n      default input #setup_time output #hold_time;\n      input sync_txd;\n      inout sync_dat;\n   endclocking: sck1\n\n   clocking sck2 @(posedge ck2);\n      default input #setup_time output #hold_time;\n      output sync_rxd;\n   endclocking: sck2\n\n\n   // ToDo: Define one clocking block per clock domain\n   //       with synchronous signal direction from a\n   //       monitor perspective\n\n   clocking pck1 @(posedge ck1);\n      default input #setup_time output #hold_time;\n      input sync_txd;\n      input sync_dat;\n   endclocking: pck1\n\n   clocking pck2 @(posedge ck2);\n      default input #setup_time output #hold_time;\n      input sync_rxd;\n   endclocking: pck2\n\n\n   // ToDo: Define a modport for each master, slave and\n   //       monitor, with appropriate asynchronous signal\n   //       directions and clocking blocks\n\n   modport master(clocking mck1,\n         clocking mck2,\n        output async_en,\n          input  async_rdy);\n\n   modport slave(clocking sck1,\n        clocking sck2,\n        input  async_en,\n      output async_rdy);\n\n   modport passive(clocking pck1,\n         clocking pck2,\n        input async_en,\n           input async_rdy);\nendinterface: $1\n" "VMM Interface (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("modport" "modport ${1:name_mp}\n  ($0\n   // clocking clocking_cb,\n   // input input_name,\n   // output output_port,\n   // ....\n   );\n" "modport .. { .. }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("module" "module ${1:module_name} (/*port details*/);\n  $0\nendmodule: $1\n" "module .. endmodule" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("once" "\\`ifndef ${1:_`(upcase (file-name-nondirectory (file-name-sans-extension (buffer-file-name))))`_`(upcase (file-name-extension (buffer-file-name)))`_}\n\\`define $1\n\n$0\n\n\\`endif // $1\n" "`ifndef XXX; `define XXX; `endif" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region t))
                        nil nil)
                       ("ovm" "class ${1:ovc_name}_agent extends ovm_agent;\n\n   ovm_active_passive_enum is_active;\n   $1_sequencer sequencer;\n   $1_driver driver;\n   $1_monitor monitor;\n\n   \\`ovm_component_utils_begin($1_agent)\n      \\`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      monitor=$1_monitor::type_id::create(\"monitor\", this);\n      if (is_active == OVM_ACTIVE)\n begin\n    driver=$1_driver::type_id::create(\"driver\", this);\n      sequencer=$1_sequencer::type_id::create(\"sequencer\", this);\n  end\n   endfunction: build\n\n   virtual function void connect();\n      if (is_active == OVM_ACTIVE)\n begin\n    driver.seq_item_port.connect(sequencer.seq_item_export);\n   end\n   endfunction: connect\n\n   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);\n      monitor.vif = vif;\n      if (is_active == OVM_ACTIVE)\n        begin\n     driver.vif=vif;\n        end\n   endfunction: assign_vif\n\nendclass: $1_agent\n" "OVM Agent" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class ${1:ovc_item} extends ovm_sequence_item;\n   $0\n   /* AUTO_OVM_VARS */\n   rand bit [3:0] addr;\n   rand bit [5:0] length;\n   rand bit [7:0] payload [];\n   \n   \\`ovm_object_utils_begin(yapp_pkt)\n      \\`ovm_field_int(addr, OVM_ALL_ON)\n      \\`ovm_field_int(length, OVM_ALL_ON)\n      \\`ovm_field_array_int(payload, OVM_ALL_ON)\n   \\`ovm_object_utils_end\n\n   function new(string name=\"$1\");\n      super.new(name);\n   endfunction: new\n\nendclass: $1\n" "OVM Data Item" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});\n\n   string tID;\n   virtual interface ${3:ovc_if} vif;\n   $2 item;\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   \\`ovm_component_utils_begin($1_driver)\n      \\`ovm_field_object(item, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task get_and_drive();\n      forever\n   begin\n    // wait(vif.reset==0);  // block until reset released\n     seq_item_port.get_next_item(item);\n    send_to_dut(item);\n    seq_item_port.item_done();\n end\n   endtask: get_and_drive\n\n   task send_to_dut(input $2 item);\n      ovm_report_info(tID, $psprintf(\"%s : item sent is %0s\",\n                     tID, item.sprint()), OVM_FULL);\n      // Send data to DUT (BFM - fill in your BFM code here)\n      #10 ;\n      #10 ;\n   endtask: send_to_dut\n\n   task reset_dut();\n      // fill in any reset code here\n   endtask: reset_dut\n\n   task run();\n      ovm_report_info(tID, $psprintf(\" %s : running\", tID), OVM_MEDIUM);\n      // reset_dut(); // fill in 'reset_dut()' if needed\n      get_and_drive();\n   endtask: run\n\n   virtual function void report();\n      // fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\nendclass: $1_driver\n" "OVM Driver" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class ${1:ovc_name}_env extends ovm_env;\n\n   $1_agent agent0;\n   \\`ovm_component_utils($1_env)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      agent0 = $1_agent::type_id::create(\"agent0\", this);\n   endfunction: build\n\nendclass: $1_env\n" "OVM Env" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "interface $1(input logic clock, input logic reset);\n\n   // ToDo: Declare the interface signals corresponding to the ports\n$0   wire [7:0] sync_tx;\n   wire [7:0] sync_rx;\n\n   logic async_sig;\n   \n   // ToDo: Define clocking blocks\n   // -- use the 'clocking' snippet\n   \n   // ToDo: Define a modport for each interface perspective\n   // -- use the 'modport' snippet\n\nendinterface: $1\n" "OVM Interface" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class ${1:ovc_name}_monitor extends ovm_monitor;\n\n   string tID;\n   virtual interface ${2:ovc_if} vif;\n   ${3:ovc_item} trans;\n   event e_trans_collected; // event to signal transaction collected\n   // TLM port for scoreboard communication\n   //  (implement scoreboard write method if needed)\n   ovm_analysis_port #($3) sb_post;\n\n   \\`ovm_component_utils_begin($1_monitor)\n      \\`ovm_field_object(trans, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task collect_data();\n      forever\n begin\n    //put code to collect bus transactions here\n       #10 ;\n\n       #10 ;\n\n       ->e_trans_collected; //signal transaction collection complete\n     //post good transactions to scoreboard if enabled\n     if (sb_post.size() > 0)\n         sb_post.write(trans);\n    end;\n   endtask: collect_data\n\n   // to FIX stuff for covergroup\n   /*\n    //shell code for covergroup\n    covergroup cov_trans @ e_trans_collected;\n    cg1: coverpoint trans..$fields[2].\n    { bins MIN[]     = {0};\n    bins MAX[]     = {63};\n    }\nendgroup\n    */\n\n   task run();\n      \\`message(OVM_MEDIUM, (\"$1_monitor: running\"))\n      ovm_report_info(tID, $psprintf(\"%s: running\", tID), OVM_MEDIUM);\n      collect_data();\n   endtask: run\n\n   virtual function void report();\n      //fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\n\n   //new() function needs to be listed last so other items defined\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n      // to FIX stuff for covergroup\n      /*\n       cov_trans = new();\n       cov_trans.set_inst_name({get_full_name(), \".cov_trans\"});\n       */\n      trans = new();\n      sb_post = new(\"sb_post\", this);\n   endfunction: new\n\nendclass: $1_monitor\n" "OVM Monitor" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});\n\n   string tID;\n   \\`ovm_sequence_utils($1_seq1, $1_sequencer)\n   // $2 trans;\n   // \"req\" built-in ovm_sequence class member for sequence_item\n   rand int delay1;\n   rand int delay2;\n   constraint d1 {delay1 > 55; delay1 < 125;}\n   constraint d2 {delay2 > 25; delay2 < 45;}\n\n   function new(string name = \"$1_seq1\");\n      super.new(name);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   task body();\n      \\`message(OVM_LOW, (\"RUNNING sequence: %s\", get_name()))\n      ovm_report_info(tID, $psprintf(\"%s: sequence Running\", tID), OVM_LOW);\n      // not the best way to print, just to confirm randomization\n      \\`message(OVM_LOW, (\"delay1=%0d, delay2=%0d\", delay1, delay2))\n      ovm_report_info(tID, $psprintf(\"%s: delay1=%0d, delay2=%0d\",\n                    tID, delay1, delay2), OVM_MEDIUM);\n      #delay1\n    // dummy delay to illustrate a sequence rand variable\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n  // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay2\n  // get_response(rsp); // get response if implemented\n      \\`message(OVM_LOW, (\"sequence: %s complete\", get_name()))\n      ovm_report_info(tID, $psprintf(\"sequence: %s complete\", tID), OVM_LOW);\n   endtask: body\n\nendclass: $1_seq1\n\n//additional sequences can be included in this file\n" "OVM Seq Lib" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});\n\n   \\`ovm_sequencer_utils($1_sequencer)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      \\`ovm_update_sequence_lib_and_item($2)\n   endfunction: new\n\nendclass: $1_sequencer\n" "OVM Sequencer" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class sve extends ovm_env;\n   ${1:ovc_name}_env env0;\n   \\`ovm_component_utils(sve)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      env0 = $1_env::type_id::create(\"env0\", this);\n   endfunction: build\n\n   virtual function void connect();\n      env0.agent0.assign_vif(top.if0);\n   endfunction: connect\nendclass: sve\n" "OVM Sve" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "class test1 extends ovm_test;\n\n     sve sve0;\n     \\`ovm_component_utils(test1)\n\n     function new(string name, ovm_component parent);\n   super.new(name, parent);\n     endfunction: new\n\n   virtual function void build();\n      super.build();\n      set_config_int(\"sve0.env0.agent0.sequencer\", \"count\", 2);\n      set_config_int(\"sve0.env0.agent0\", \"is_active\", OVM_ACTIVE);\n      set_config_string(\"sve0.env0.agent0.sequencer\",\n          \"default_sequence\", \"${1:ovc_name}_seq1\");\n      sve0 = sve::type_id::create(\"sve0\", this);\n   endfunction: build\n\n   task run();\n      \\`message(OVM_LOW, (\"test1 running...\"))\n      ovm_top.print_topology();\n      #10000\n //delay is simple \"end of test\" mechanism\n   //use objections in sequences for better \"end of test\" detection\n    \\`message(OVM_LOW, (\"User activated end of simulation\"))\n      global_stop_request();\n   endtask: run\n\nendclass: test1\n" "OVM Test" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm" "\\`include \"ovm.svh\"\n\\`include \"${1:ovc_name}_inc.svh\"\n\\`include \"sve.sv\"\n\\`include \"test1.sv\"\nmodule top();\n\n   logic clock;\n   logic reset;\n\n   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface\n\n   initial\n     begin\n    run_test();\n     end\n\n   always #10 clock = ~clock;\n\n   initial\n     begin\n  clock = 0;\n    reset = 1; // active high reset for this example\n  #75 reset = 0;\n     end\n\n   // instantiate and connect dut to interface(s) here\n\nendmodule: top\n" "OVM Top" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_agent" "class ${1:ovc_name}_agent extends ovm_agent;\n\n   ovm_active_passive_enum is_active;\n   $1_sequencer sequencer;\n   $1_driver driver;\n   $1_monitor monitor;\n\n   \\`ovm_component_utils_begin($1_agent)\n      \\`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      monitor=$1_monitor::type_id::create(\"monitor\", this);\n      if (is_active == OVM_ACTIVE)\n   begin\n    driver=$1_driver::type_id::create(\"driver\", this);\n      sequencer=$1_sequencer::type_id::create(\"sequencer\", this);\n  end\n   endfunction: build\n\n   virtual function void connect();\n      if (is_active == OVM_ACTIVE)\n begin\n    driver.seq_item_port.connect(sequencer.seq_item_export);\n   end\n   endfunction: connect\n\n   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);\n      monitor.vif = vif;\n      if (is_active == OVM_ACTIVE)\n        begin\n     driver.vif=vif;\n        end\n   endfunction: assign_vif\n\nendclass: $1_agent\n" "OVM Agent" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_data" "class ${1:ovc_item} extends ovm_sequence_item;\n   $0\n   /* AUTO_OVM_VARS */\n   rand bit [3:0] addr;\n   rand bit [5:0] length;\n   rand bit [7:0] payload [];\n   \n   \\`ovm_object_utils_begin(yapp_pkt)\n      \\`ovm_field_int(addr, OVM_ALL_ON)\n      \\`ovm_field_int(length, OVM_ALL_ON)\n      \\`ovm_field_array_int(payload, OVM_ALL_ON)\n   \\`ovm_object_utils_end\n\n   function new(string name=\"$1\");\n      super.new(name);\n   endfunction: new\n\nendclass: $1\n" "OVM Data Item" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_data_item" "class ${1:ovc_item} extends ovm_sequence_item;\n   $0\n   /* AUTO_OVM_VARS */\n   rand bit [3:0] addr;\n   rand bit [5:0] length;\n   rand bit [7:0] payload [];\n   \n   \\`ovm_object_utils_begin(yapp_pkt)\n      \\`ovm_field_int(addr, OVM_ALL_ON)\n      \\`ovm_field_int(length, OVM_ALL_ON)\n      \\`ovm_field_array_int(payload, OVM_ALL_ON)\n   \\`ovm_object_utils_end\n\n   function new(string name=\"$1\");\n      super.new(name);\n   endfunction: new\n\nendclass: $1\n" "OVM Data Item" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_driver" "class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});\n\n   string tID;\n   virtual interface ${3:ovc_if} vif;\n   $2 item;\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   \\`ovm_component_utils_begin($1_driver)\n      \\`ovm_field_object(item, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task get_and_drive();\n      forever\n    begin\n    // wait(vif.reset==0);  // block until reset released\n     seq_item_port.get_next_item(item);\n    send_to_dut(item);\n    seq_item_port.item_done();\n end\n   endtask: get_and_drive\n\n   task send_to_dut(input $2 item);\n      ovm_report_info(tID, $psprintf(\"%s : item sent is %0s\",\n                     tID, item.sprint()), OVM_FULL);\n      // Send data to DUT (BFM - fill in your BFM code here)\n      #10 ;\n      #10 ;\n   endtask: send_to_dut\n\n   task reset_dut();\n      // fill in any reset code here\n   endtask: reset_dut\n\n   task run();\n      ovm_report_info(tID, $psprintf(\" %s : running\", tID), OVM_MEDIUM);\n      // reset_dut(); // fill in 'reset_dut()' if needed\n      get_and_drive();\n   endtask: run\n\n   virtual function void report();\n      // fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\nendclass: $1_driver\n" "OVM Driver" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_env" "class ${1:ovc_name}_env extends ovm_env;\n\n   $1_agent agent0;\n   \\`ovm_component_utils($1_env)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      agent0 = $1_agent::type_id::create(\"agent0\", this);\n   endfunction: build\n\nendclass: $1_env\n" "OVM Env" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_item" "class ${1:ovc_item} extends ovm_sequence_item;\n   $0\n   /* AUTO_OVM_VARS */\n   rand bit [3:0] addr;\n   rand bit [5:0] length;\n   rand bit [7:0] payload [];\n   \n   \\`ovm_object_utils_begin(yapp_pkt)\n      \\`ovm_field_int(addr, OVM_ALL_ON)\n      \\`ovm_field_int(length, OVM_ALL_ON)\n      \\`ovm_field_array_int(payload, OVM_ALL_ON)\n   \\`ovm_object_utils_end\n\n   function new(string name=\"$1\");\n      super.new(name);\n   endfunction: new\n\nendclass: $1\n" "OVM Data Item" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_mon" "class ${1:ovc_name}_monitor extends ovm_monitor;\n\n   string tID;\n   virtual interface ${2:ovc_if} vif;\n   ${3:ovc_item} trans;\n   event e_trans_collected; // event to signal transaction collected\n   // TLM port for scoreboard communication\n   //  (implement scoreboard write method if needed)\n   ovm_analysis_port #($3) sb_post;\n\n   \\`ovm_component_utils_begin($1_monitor)\n      \\`ovm_field_object(trans, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task collect_data();\n      forever\n begin\n    //put code to collect bus transactions here\n       #10 ;\n\n       #10 ;\n\n       ->e_trans_collected; //signal transaction collection complete\n     //post good transactions to scoreboard if enabled\n     if (sb_post.size() > 0)\n         sb_post.write(trans);\n    end;\n   endtask: collect_data\n\n   // to FIX stuff for covergroup\n   /*\n    //shell code for covergroup\n    covergroup cov_trans @ e_trans_collected;\n    cg1: coverpoint trans..$fields[2].\n    { bins MIN[]     = {0};\n    bins MAX[]     = {63};\n    }\nendgroup\n    */\n\n   task run();\n      \\`message(OVM_MEDIUM, (\"$1_monitor: running\"))\n      ovm_report_info(tID, $psprintf(\"%s: running\", tID), OVM_MEDIUM);\n      collect_data();\n   endtask: run\n\n   virtual function void report();\n      //fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\n\n   //new() function needs to be listed last so other items defined\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n      // to FIX stuff for covergroup\n      /*\n       cov_trans = new();\n       cov_trans.set_inst_name({get_full_name(), \".cov_trans\"});\n       */\n      trans = new();\n      sb_post = new(\"sb_post\", this);\n   endfunction: new\n\nendclass: $1_monitor\n" "OVM Monitor" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_monitor" "class ${1:ovc_name}_monitor extends ovm_monitor;\n\n   string tID;\n   virtual interface ${2:ovc_if} vif;\n   ${3:ovc_item} trans;\n   event e_trans_collected; // event to signal transaction collected\n   // TLM port for scoreboard communication\n   //  (implement scoreboard write method if needed)\n   ovm_analysis_port #($3) sb_post;\n\n   \\`ovm_component_utils_begin($1_monitor)\n      \\`ovm_field_object(trans, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task collect_data();\n      forever\n begin\n    //put code to collect bus transactions here\n       #10 ;\n\n       #10 ;\n\n       ->e_trans_collected; //signal transaction collection complete\n     //post good transactions to scoreboard if enabled\n     if (sb_post.size() > 0)\n         sb_post.write(trans);\n    end;\n   endtask: collect_data\n\n   // to FIX stuff for covergroup\n   /*\n    //shell code for covergroup\n    covergroup cov_trans @ e_trans_collected;\n    cg1: coverpoint trans..$fields[2].\n    { bins MIN[]     = {0};\n    bins MAX[]     = {63};\n    }\nendgroup\n    */\n\n   task run();\n      \\`message(OVM_MEDIUM, (\"$1_monitor: running\"))\n      ovm_report_info(tID, $psprintf(\"%s: running\", tID), OVM_MEDIUM);\n      collect_data();\n   endtask: run\n\n   virtual function void report();\n      //fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\n\n   //new() function needs to be listed last so other items defined\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n      // to FIX stuff for covergroup\n      /*\n       cov_trans = new();\n       cov_trans.set_inst_name({get_full_name(), \".cov_trans\"});\n       */\n      trans = new();\n      sb_post = new(\"sb_post\", this);\n   endfunction: new\n\nendclass: $1_monitor\n" "OVM Monitor" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_seq_lib" "class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});\n\n   string tID;\n   \\`ovm_sequence_utils($1_seq1, $1_sequencer)\n   // $2 trans;\n   // \"req\" built-in ovm_sequence class member for sequence_item\n   rand int delay1;\n   rand int delay2;\n   constraint d1 {delay1 > 55; delay1 < 125;}\n   constraint d2 {delay2 > 25; delay2 < 45;}\n\n   function new(string name = \"$1_seq1\");\n      super.new(name);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   task body();\n      \\`message(OVM_LOW, (\"RUNNING sequence: %s\", get_name()))\n      ovm_report_info(tID, $psprintf(\"%s: sequence Running\", tID), OVM_LOW);\n      // not the best way to print, just to confirm randomization\n      \\`message(OVM_LOW, (\"delay1=%0d, delay2=%0d\", delay1, delay2))\n      ovm_report_info(tID, $psprintf(\"%s: delay1=%0d, delay2=%0d\",\n                    tID, delay1, delay2), OVM_MEDIUM);\n      #delay1\n    // dummy delay to illustrate a sequence rand variable\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n  // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay2\n  // get_response(rsp); // get response if implemented\n      \\`message(OVM_LOW, (\"sequence: %s complete\", get_name()))\n      ovm_report_info(tID, $psprintf(\"sequence: %s complete\", tID), OVM_LOW);\n   endtask: body\n\nendclass: $1_seq1\n\n//additional sequences can be included in this file\n" "OVM Seq Lib" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_seqlib" "class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});\n\n   string tID;\n   \\`ovm_sequence_utils($1_seq1, $1_sequencer)\n   // $2 trans;\n   // \"req\" built-in ovm_sequence class member for sequence_item\n   rand int delay1;\n   rand int delay2;\n   constraint d1 {delay1 > 55; delay1 < 125;}\n   constraint d2 {delay2 > 25; delay2 < 45;}\n\n   function new(string name = \"$1_seq1\");\n      super.new(name);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   task body();\n      \\`message(OVM_LOW, (\"RUNNING sequence: %s\", get_name()))\n      ovm_report_info(tID, $psprintf(\"%s: sequence Running\", tID), OVM_LOW);\n      // not the best way to print, just to confirm randomization\n      \\`message(OVM_LOW, (\"delay1=%0d, delay2=%0d\", delay1, delay2))\n      ovm_report_info(tID, $psprintf(\"%s: delay1=%0d, delay2=%0d\",\n                     tID, delay1, delay2), OVM_MEDIUM);\n      #delay1\n    // dummy delay to illustrate a sequence rand variable\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n  // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay2\n  // get_response(rsp); // get response if implemented\n      \\`message(OVM_LOW, (\"sequence: %s complete\", get_name()))\n      ovm_report_info(tID, $psprintf(\"sequence: %s complete\", tID), OVM_LOW);\n   endtask: body\n\nendclass: $1_seq1\n\n//additional sequences can be included in this file\n" "OVM Seq Lib" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_sequence_item" "class ${1:ovc_item} extends ovm_sequence_item;\n   $0\n   /* AUTO_OVM_VARS */\n   rand bit [3:0] addr;\n   rand bit [5:0] length;\n   rand bit [7:0] payload [];\n   \n   \\`ovm_object_utils_begin(yapp_pkt)\n      \\`ovm_field_int(addr, OVM_ALL_ON)\n      \\`ovm_field_int(length, OVM_ALL_ON)\n      \\`ovm_field_array_int(payload, OVM_ALL_ON)\n   \\`ovm_object_utils_end\n\n   function new(string name=\"$1\");\n      super.new(name);\n   endfunction: new\n\nendclass: $1\n" "OVM Data Item" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_sequencer" "class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});\n\n   \\`ovm_sequencer_utils($1_sequencer)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      \\`ovm_update_sequence_lib_and_item($2)\n   endfunction: new\n\nendclass: $1_sequencer\n" "OVM Sequencer" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_sve" "class sve extends ovm_env;\n   ${1:ovc_name}_env env0;\n   \\`ovm_component_utils(sve)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      env0 = $1_env::type_id::create(\"env0\", this);\n   endfunction: build\n\n   virtual function void connect();\n      env0.agent0.assign_vif(top.if0);\n   endfunction: connect\nendclass: sve\n" "OVM Sve" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_test" "class test1 extends ovm_test;\n\n     sve sve0;\n     \\`ovm_component_utils(test1)\n\n     function new(string name, ovm_component parent);\n  super.new(name, parent);\n     endfunction: new\n\n   virtual function void build();\n      super.build();\n      set_config_int(\"sve0.env0.agent0.sequencer\", \"count\", 2);\n      set_config_int(\"sve0.env0.agent0\", \"is_active\", OVM_ACTIVE);\n      set_config_string(\"sve0.env0.agent0.sequencer\",\n          \"default_sequence\", \"${1:ovc_name}_seq1\");\n      sve0 = sve::type_id::create(\"sve0\", this);\n   endfunction: build\n\n   task run();\n      \\`message(OVM_LOW, (\"test1 running...\"))\n      ovm_top.print_topology();\n      #10000\n //delay is simple \"end of test\" mechanism\n   //use objections in sequences for better \"end of test\" detection\n    \\`message(OVM_LOW, (\"User activated end of simulation\"))\n      global_stop_request();\n   endtask: run\n\nendclass: test1\n" "OVM Test" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovm_top" "\\`include \"ovm.svh\"\n\\`include \"${1:ovc_name}_inc.svh\"\n\\`include \"sve.sv\"\n\\`include \"test1.sv\"\nmodule top();\n\n   logic clock;\n   logic reset;\n\n   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface\n\n   initial\n     begin\n    run_test();\n     end\n\n   always #10 clock = ~clock;\n\n   initial\n     begin\n  clock = 0;\n    reset = 1; // active high reset for this example\n  #75 reset = 0;\n     end\n\n   // instantiate and connect dut to interface(s) here\n\nendmodule: top\n" "OVM Top" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmagent" "class ${1:ovc_name}_agent extends ovm_agent;\n\n   ovm_active_passive_enum is_active;\n   $1_sequencer sequencer;\n   $1_driver driver;\n   $1_monitor monitor;\n\n   \\`ovm_component_utils_begin($1_agent)\n      \\`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      monitor=$1_monitor::type_id::create(\"monitor\", this);\n      if (is_active == OVM_ACTIVE)\n    begin\n    driver=$1_driver::type_id::create(\"driver\", this);\n      sequencer=$1_sequencer::type_id::create(\"sequencer\", this);\n  end\n   endfunction: build\n\n   virtual function void connect();\n      if (is_active == OVM_ACTIVE)\n begin\n    driver.seq_item_port.connect(sequencer.seq_item_export);\n   end\n   endfunction: connect\n\n   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);\n      monitor.vif = vif;\n      if (is_active == OVM_ACTIVE)\n        begin\n     driver.vif=vif;\n        end\n   endfunction: assign_vif\n\nendclass: $1_agent\n" "OVM Agent" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmdriver" "class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});\n\n   string tID;\n   virtual interface ${3:ovc_if} vif;\n   $2 item;\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   \\`ovm_component_utils_begin($1_driver)\n      \\`ovm_field_object(item, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task get_and_drive();\n      forever\n begin\n    // wait(vif.reset==0);  // block until reset released\n     seq_item_port.get_next_item(item);\n    send_to_dut(item);\n    seq_item_port.item_done();\n end\n   endtask: get_and_drive\n\n   task send_to_dut(input $2 item);\n      ovm_report_info(tID, $psprintf(\"%s : item sent is %0s\",\n                     tID, item.sprint()), OVM_FULL);\n      // Send data to DUT (BFM - fill in your BFM code here)\n      #10 ;\n      #10 ;\n   endtask: send_to_dut\n\n   task reset_dut();\n      // fill in any reset code here\n   endtask: reset_dut\n\n   task run();\n      ovm_report_info(tID, $psprintf(\" %s : running\", tID), OVM_MEDIUM);\n      // reset_dut(); // fill in 'reset_dut()' if needed\n      get_and_drive();\n   endtask: run\n\n   virtual function void report();\n      // fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\nendclass: $1_driver\n" "OVM Driver" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmenv" "class ${1:ovc_name}_env extends ovm_env;\n\n   $1_agent agent0;\n   \\`ovm_component_utils($1_env)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      agent0 = $1_agent::type_id::create(\"agent0\", this);\n   endfunction: build\n\nendclass: $1_env\n" "OVM Env" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmmon" "class ${1:ovc_name}_monitor extends ovm_monitor;\n\n   string tID;\n   virtual interface ${2:ovc_if} vif;\n   ${3:ovc_item} trans;\n   event e_trans_collected; // event to signal transaction collected\n   // TLM port for scoreboard communication\n   //  (implement scoreboard write method if needed)\n   ovm_analysis_port #($3) sb_post;\n\n   \\`ovm_component_utils_begin($1_monitor)\n      \\`ovm_field_object(trans, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task collect_data();\n      forever\n  begin\n    //put code to collect bus transactions here\n       #10 ;\n\n       #10 ;\n\n       ->e_trans_collected; //signal transaction collection complete\n     //post good transactions to scoreboard if enabled\n     if (sb_post.size() > 0)\n         sb_post.write(trans);\n    end;\n   endtask: collect_data\n\n   // to FIX stuff for covergroup\n   /*\n    //shell code for covergroup\n    covergroup cov_trans @ e_trans_collected;\n    cg1: coverpoint trans..$fields[2].\n    { bins MIN[]     = {0};\n    bins MAX[]     = {63};\n    }\nendgroup\n    */\n\n   task run();\n      \\`message(OVM_MEDIUM, (\"$1_monitor: running\"))\n      ovm_report_info(tID, $psprintf(\"%s: running\", tID), OVM_MEDIUM);\n      collect_data();\n   endtask: run\n\n   virtual function void report();\n      //fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\n\n   //new() function needs to be listed last so other items defined\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n      // to FIX stuff for covergroup\n      /*\n       cov_trans = new();\n       cov_trans.set_inst_name({get_full_name(), \".cov_trans\"});\n       */\n      trans = new();\n      sb_post = new(\"sb_post\", this);\n   endfunction: new\n\nendclass: $1_monitor\n" "OVM Monitor" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmmonitor" "class ${1:ovc_name}_monitor extends ovm_monitor;\n\n   string tID;\n   virtual interface ${2:ovc_if} vif;\n   ${3:ovc_item} trans;\n   event e_trans_collected; // event to signal transaction collected\n   // TLM port for scoreboard communication\n   //  (implement scoreboard write method if needed)\n   ovm_analysis_port #($3) sb_post;\n\n   \\`ovm_component_utils_begin($1_monitor)\n      \\`ovm_field_object(trans, OVM_ALL_ON)\n   \\`ovm_component_utils_end\n\n   task collect_data();\n      forever\n  begin\n    //put code to collect bus transactions here\n       #10 ;\n\n       #10 ;\n\n       ->e_trans_collected; //signal transaction collection complete\n     //post good transactions to scoreboard if enabled\n     if (sb_post.size() > 0)\n         sb_post.write(trans);\n    end;\n   endtask: collect_data\n\n   // to FIX stuff for covergroup\n   /*\n    //shell code for covergroup\n    covergroup cov_trans @ e_trans_collected;\n    cg1: coverpoint trans..$fields[2].\n    { bins MIN[]     = {0};\n    bins MAX[]     = {63};\n    }\nendgroup\n    */\n\n   task run();\n      \\`message(OVM_MEDIUM, (\"$1_monitor: running\"))\n      ovm_report_info(tID, $psprintf(\"%s: running\", tID), OVM_MEDIUM);\n      collect_data();\n   endtask: run\n\n   virtual function void report();\n      //fill in any reporting code if needed\n      logic dummy;\n   endfunction: report\n\n   //new() function needs to be listed last so other items defined\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      tID = get_type_name();\n      tID = tID.toupper();\n      // to FIX stuff for covergroup\n      /*\n       cov_trans = new();\n       cov_trans.set_inst_name({get_full_name(), \".cov_trans\"});\n       */\n      trans = new();\n      sb_post = new(\"sb_post\", this);\n   endfunction: new\n\nendclass: $1_monitor\n" "OVM Monitor" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmseqlib" "class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});\n\n   string tID;\n   \\`ovm_sequence_utils($1_seq1, $1_sequencer)\n   // $2 trans;\n   // \"req\" built-in ovm_sequence class member for sequence_item\n   rand int delay1;\n   rand int delay2;\n   constraint d1 {delay1 > 55; delay1 < 125;}\n   constraint d2 {delay2 > 25; delay2 < 45;}\n\n   function new(string name = \"$1_seq1\");\n      super.new(name);\n      tID = get_type_name();\n      tID = tID.toupper();\n   endfunction: new\n\n   task body();\n      \\`message(OVM_LOW, (\"RUNNING sequence: %s\", get_name()))\n      ovm_report_info(tID, $psprintf(\"%s: sequence Running\", tID), OVM_LOW);\n      // not the best way to print, just to confirm randomization\n      \\`message(OVM_LOW, (\"delay1=%0d, delay2=%0d\", delay1, delay2))\n      ovm_report_info(tID, $psprintf(\"%s: delay1=%0d, delay2=%0d\",\n                  tID, delay1, delay2), OVM_MEDIUM);\n      #delay1\n    // dummy delay to illustrate a sequence rand variable\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay1\n  // get_response(rsp); // get response if implemented\n      \\`ovm_do(req) // this line sends the transaction\n      #delay2\n  // get_response(rsp); // get response if implemented\n      \\`message(OVM_LOW, (\"sequence: %s complete\", get_name()))\n      ovm_report_info(tID, $psprintf(\"sequence: %s complete\", tID), OVM_LOW);\n   endtask: body\n\nendclass: $1_seq1\n\n//additional sequences can be included in this file\n" "OVM Seq Lib" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmsequencer" "class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});\n\n   \\`ovm_sequencer_utils($1_sequencer)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n      \\`ovm_update_sequence_lib_and_item($2)\n   endfunction: new\n\nendclass: $1_sequencer\n" "OVM Sequencer" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmsve" "class sve extends ovm_env;\n   ${1:ovc_name}_env env0;\n   \\`ovm_component_utils(sve)\n\n   function new(string name, ovm_component parent);\n      super.new(name, parent);\n   endfunction: new\n\n   virtual function void build();\n      super.build();\n      env0 = $1_env::type_id::create(\"env0\", this);\n   endfunction: build\n\n   virtual function void connect();\n      env0.agent0.assign_vif(top.if0);\n   endfunction: connect\nendclass: sve\n" "OVM Sve" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmtest" "class test1 extends ovm_test;\n\n     sve sve0;\n     \\`ovm_component_utils(test1)\n\n     function new(string name, ovm_component parent);\n   super.new(name, parent);\n     endfunction: new\n\n   virtual function void build();\n      super.build();\n      set_config_int(\"sve0.env0.agent0.sequencer\", \"count\", 2);\n      set_config_int(\"sve0.env0.agent0\", \"is_active\", OVM_ACTIVE);\n      set_config_string(\"sve0.env0.agent0.sequencer\",\n          \"default_sequence\", \"${1:ovc_name}_seq1\");\n      sve0 = sve::type_id::create(\"sve0\", this);\n   endfunction: build\n\n   task run();\n      \\`message(OVM_LOW, (\"test1 running...\"))\n      ovm_top.print_topology();\n      #10000\n //delay is simple \"end of test\" mechanism\n   //use objections in sequences for better \"end of test\" detection\n    \\`message(OVM_LOW, (\"User activated end of simulation\"))\n      global_stop_request();\n   endtask: run\n\nendclass: test1\n" "OVM Test" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("ovmtop" "\\`include \"ovm.svh\"\n\\`include \"${1:ovc_name}_inc.svh\"\n\\`include \"sve.sv\"\n\\`include \"test1.sv\"\nmodule top();\n\n   logic clock;\n   logic reset;\n\n   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface\n\n   initial\n     begin\n run_test();\n     end\n\n   always #10 clock = ~clock;\n\n   initial\n     begin\n  clock = 0;\n    reset = 1; // active high reset for this example\n  #75 reset = 0;\n     end\n\n   // instantiate and connect dut to interface(s) here\n\nendmodule: top\n" "OVM Top" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("package" "package ${1:package_name};\n  $0\nendpackage: $1\n" "package .. endpackage" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("parameter" "parameter ${1:param_name} = ${2:param_value};\n" "parameter .. " nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("program" "program automatic ${1:name};\n   // declarations\n   $0\n   // Could have only initial blocks\n   initial begin\n   end\nendprogram: $1\n" "program .. { .. }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region t))
                        nil nil)
                       ("rand" "snippet rand\nrand ${1:type} ${2:name};\n\nconstraint $2_cst {\n   // define constraint here using dist, inside, = etc\n   $0\n};\n" "rand ... { ... }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("randcase" "   ${1:weight1}:\n      $0\n   ${2:weight2}:\nendcase\n" "randcase .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("repeat" "repeat(${1:N}) begin\n   $0\nend\n" "repeat(N) .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("struct" "typedef struct {\n$0\n} ${1:name_s};\n" "struct ... { ... }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region t))
                        nil nil)
                       ("task" "task ${1:task_name} ($3);\n  $0\nendtask: $1\n" "task .. endtask" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("typedef" "typedef ${1:type} ${2:type_name};\n" "typedef .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("union" "typedef union {\n   $0\n} ${1:name_u};\n" "union ... { ... }" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region t))
                        nil nil)
                       ("vmm" "// ${1:XACTN} -- Name of the transaction descriptor class\n// ${2:#(int DW=32, int AW=32)} -- Transaction Descriptor Class Parameters\n// ${3:GEN} -- Name of the Atomic generator being defined\n\ntypedef class $3;\n\nclass $3_callbacks $2 extends vmm_xactor_callbacks;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   virtual task post_inst_gen(transactor_type gen,\n               transaction_type obj,\n                 ref bit drop);\n   endtask: post_inst_gen\nendclass: $3_callbacks\n\n\nclass $3 $2 extends vmm_xactor;\n   // some typedefs to ease up parameters usage\n   typedef $3_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int unsigned stop_after_n_insts;\n\n   typedef enum int {GENERATED,\n          DONE} symbols_e;\n\n\n   transaction_type randomized_obj;\n\n   channel_type out_chan;\n\n   local int scenario_count;\n   local int obj_count;\n\n   virtual function string psdisplay(string prefix = \"\");\n      psdisplay = super.psdisplay(prefix);\n      $sformat(psdisplay, \"%s [stops after #insts %0d>%0d]\",\n          psdisplay, this.obj_count, this.stop_after_n_insts);\n      $sformat(psdisplay, \"%s\\n%sOutChan: %s(%s) [level=%0d of %0d]\",\n        psdisplay, prefix, this.out_chan.log.get_name(),\n          this.out_chan.log.get_instance(), this.out_chan.level(),\n          this.out_chan.full_level());\n      if (this.randomized_obj != null) begin\n  prefix = {prefix, \"Factory: \"};\n     psdisplay = {psdisplay, \"\\n\",\n           this.randomized_obj.psdisplay(prefix)};\n      end\n      return psdisplay;\n   endfunction: psdisplay\n\n   function new(string inst,\n      int stream_id = -1,\n       channel_type out_chan  = null);\n      super.new(\"${1:$(replace-regexp-in-string \"_\" \" \" (upcase text))} Atomic Generator\", inst, stream_id);\n\n      if (out_chan == null) begin\n   out_chan = new(\"${1:$(replace-regexp-in-string \"_\" \" \" (upcase text))} Atomic Generator output channel\",\n           inst);\n     // \\`VMM_OBJECT_SET_PARENT(out_chan, this)\n      end\n      this.out_chan = out_chan;\n      this.out_chan.set_producer(this);\n      this.log.is_above(this.out_chan.log);\n\n      this.scenario_count = 0;\n      this.obj_count = 0;\n      this.stop_after_n_insts = 0;\n\n      void'(this.notify.configure(GENERATED, vmm_notify::ONE_SHOT));\n      void'(this.notify.configure(DONE, vmm_notify::ON_OFF));\n\n      this.randomized_obj = new;\n      // \\`VMM_OBJECT_SET_PARENT(this.randomized_obj, this)\n   endfunction: new\n\n   virtual task inject(transaction_type obj,\n            ref bit dropped);\n      dropped = 0;\n\n      \\`vmm_callback(callback_type,\n           post_inst_gen(this, obj, dropped));\n\n      if (!dropped) begin\n  this.obj_count++;\n     this.notify.indicate(GENERATED, obj);\n     this.out_chan.put(obj);\n      end\n   endtask: inject\n\n   virtual function void reset_xactor(vmm_xactor::reset_e rst_typ = SOFT_RST);\n      super.reset_xactor(rst_typ);\n\n      this.out_chan.flush();\n      this.scenario_count = 0;\n      this.obj_count = 0;\n\n      if (rst_typ >= FIRM_RST) begin\n   this.notify.reset( , vmm_notify::HARD);\n      end\n\n      if (rst_typ >= HARD_RST) begin\n    this.stop_after_n_insts = 0;\n  this.randomized_obj     = new;\n      end\n   endfunction: reset_xactor\n\n   virtual protected task main();\n      bit dropped;\n\n      fork\n    super.main();\n      join_none\n\n      while (this.stop_after_n_insts <= 0 ||\n        this.obj_count < this.stop_after_n_insts) begin\n\n     this.wait_if_stopped();\n\n     this.randomized_obj.stream_id   = this.stream_id;\n     this.randomized_obj.scenario_id = this.scenario_count;\n    this.randomized_obj.data_id     = this.obj_count;\n\n   if (!this.randomized_obj.randomize()) begin\n      \\`vmm_fatal(this.log, \"Cannot randomize atomic instance\");\n     continue;\n  end\n\n     begin\n        transaction_type obj;\n\n       $cast(obj, this.randomized_obj.copy());\n       // \\`VMM_OBJECT_SET_PARENT(obj, this)\n        this.inject(obj, dropped);\n     end\n      end\n\n      this.notify.indicate(DONE);\n      this.notify.indicate(XACTOR_STOPPED);\n      this.notify.indicate(XACTOR_IDLE);\n      this.notify.reset(XACTOR_BUSY);\n      this.scenario_count++;\n   endtask: main\n\nendclass: $3\n" "VMM Atomic Gen (VMM version 1.1.1)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "class ${1:name}_env extends vmm_env;\n   // Instantiate cmd Transactors, Monitors, Configurations, Channels,\n   // and Log format controls\n\n   // Command transactors\n   $1_cmd_xactor cmd_xactor_0;\n   // Vmm Channels\n   $1_xactn_channel gen_chan_0, mon_chan_0;\n   // Configuration\n   $1_cfg test_cfg_0;\n   // Xactn Generators\n   $1_xactn_atomic_gen xactn_gen_0;\n   // Monitors\n   $1_mon_xactor mon_0;\n   // Format Controls\n   $1_log_fmt log_fmt_cntl;\n\n   function new();              // for environment\n      super.new();\n      $timeformat(-9,2, \" ns\");\n      this.test_cfg_0 = new();\n      log_fmt_cntl = new();\n      log.set_format(log_fmt_cntl);\n   endfunction: new\n\n   // These tasks are mandated by VMM\n   extern function void gen_cfg();\n   extern function void build();\n   extern task reset_dut();\n   extern task start();\n   extern task run();\n   extern task wait_for_end();\n   extern task stop();\n   extern task report();\nendclass: $1_env\n\nfunction void $1_env::gen_cfg();\n   super.gen_cfg();\n   this.test_cfg_0.randomize();\nendfunction: gen_cfg\n\nfunction void $1_env::build();\n   string msg;\n   super.build();\n   // Instantiation of channel\n   this.gen_chan_0 = new(\"$1_chan\",\"channel\");\n   this.response_chan_0 = new(\"$1_response_channel\", \"channel\");\n   // Instantiation of command-layer transactor\n   this.cmd_xactor_0 = new(\"cmd_xactor\",\n               0,\n            \\`TOP.f_if,\n              $1_channel_0,\n             $1_response_chan0\n             );\n   // Instantiation of transaction generator\n   this.xactn_gen_0 = new (\"$1_gen\", 0, $1_channel_0);\n   this.xactn_gen_0.stop_after_n_insts = this.test_cfg_0.no_of_xactions;\n   // Setting up a message, then send it\n   $sformat(msg, \"Sim shall run for no_of_xactions %0d \",\n        this.xactn_gen_0.stop_after_n_insts);\n   \\`vmm_note(log, msg);\n   // Instantiation of monitor channel\n   this.mon_chan_0 = new(\"$1_mon_chan_0\",\"channel\");\n   // Instantiation of monitor\n   this.mon_0 = new(\"$1 Mon\", 0, \\`TOP.f_if,\n           this.$1_mon_chan_0);\n\nendfunction: build\n\n\n\ntask $1_env::reset_dut();\n   super.reset_dut();\n   // Code to reset the DUT to be kept here\nendtask: reset_dut\n\ntask $1_env::run();\n   super.run();\nendtask: run\n\ntask $1_env::start();\n   // May use factory patterns\n   $1_xactn injection_xactn;\n   bit dropped;\n   injection_xactn=new;\n   super.start();\n   //this.xactn_gen_0.start_xactor();\n   this.cmd_xactor_0.start_xactor();\n   this.mon_0.start_xactor();\n   this.mon_chan_0.sink(); // flush content of channel\n   \\`vmm_note(log, \"Start of Inject\");\n   for (int i = 0; i < 15; i++) begin\n      dropped = 0;\n      injection_xactn.randomize() with\n   {data < 5; kind==PUSH;};\n      this.xactn_gen_0.inject(injection_xactn, dropped);\n   end\n   \\`vmm_note(log, \"End of Inject, start of gen0 xactor\");\n   this.xactn_gen_0.start_xactor();\n\n   //\nendtask: start\n\ntask $1_env::wait_for_end();\n   super.wait_for_end();\n   this.xactn_gen_0.notify.wait_for($1_xactn_atomic_gen::DONE);\nendtask: wait_for_end\n\ntask $1_env::stop();\n   super.stop();\n   $finish;\nendtask: stop\n\n\ntask $1_env:: report();\n   super.report();\n   \\`vmm_note(log, \"This is where additional model info is displayed\");\n   \\`vmm_note(log, \"**** REPORT ***\");\nendtask: report\n" "VMM Env" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant full-duplex functional-level transactor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:TR}         Name of high-level transaction descriptor class\n// ${4:TX}         Name of low-level transaction descriptor class\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$4.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n   // ToDo: Add additional relevant callbacks\n   // ToDo: Use a task if callbacks can be blocking\n\n   // Called before a transaction is executed\n   virtual task pre_trans(transactor_type xactor,\n                          hi_transaction_type tr,\n                          bit drop);\n   endtask: pre_trans\n\n   virtual function void pre_trans_exec(transactor_type xactor,\n                                        hi_transaction_type tr,\n                                        lo_transaction_type tx[$]);\n   endfunction: pre_trans_exec\n\n   // Called at start of lower transaction\n   virtual task pre_exec(transactor_type xactor,\n                         lo_transaction_type tx,\n                         bit drop);\n   endtask: pre_exec\n\n   // Called at end of lower transaction\n   virtual task post_exec(transactor_type xactor,\n                          lo_transaction_type tx);\n   endtask: post_exec\n\n   virtual function void post_trans_exec(transactor_type xactor,\n                                         hi_transaction_type tr,\n                                         lo_transaction_type tx[$]);\n   endfunction: post_trans_exec\n\n   // Called after a transaction has been executed\n   virtual task post_in_trans(transactor_type xactor,\n                              hi_transaction_type tr);\n   endtask: post_in_trans\n\n   // Called at end of observed lower-level transaction\n   virtual function void post_trans_obs(transactor_type xactor,\n                                        lo_transaction_type tx,\n                                        bit drop);\n   endfunction: post_trans_obs\n\n   // Call when a high-level transaction has been identified\n   virtual function void post_out_trans(transactor_type xactor,\n                                        lo_transaction_type tx[$],\n                                        hi_transaction_type tr,\n                                        bit drop);\n   endfunction: post_out_trans\nendclass: $1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass: $1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;\n   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int EXECUTING;\n   int SUB_EXECUTING;\n   int OBSERVED;\n   int SUB_OBSERVED;\n\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n   protected hi_transaction_type rx_factory;\n   local     hi_transaction_type reset_rx_factory;\n\n   hi_channel_type in_chan;\n   hi_channel_type out_chan;\n   lo_channel_type exec_chan;\n   lo_channel_type obs_chan;\n\n   extern function new (string inst,\n                        int stream_id,\n                        configuration_type cfg = null,\n                        hi_channel_type in_chan = null,\n                        hi_channel_type out_chan = null,\n                        lo_channel_type exec_chan = null,\n                        lo_channel_type obs_chan = null,\n                        hi_transaction_type rx_factory = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n   extern protected virtual task tx_driver();\n   extern protected virtual task rx_monitor();\n\nendclass: $1\n\n\nfunction $1::new(string inst,\n                 int stream_id,\n                 configuration_type cfg,\n                 hi_channel_type in_chan,\n                 hi_channel_type out_chan,\n                 lo_channel_type exec_chan,\n                 lo_channel_type obs_chan,\n                 hi_transaction_type rx_factory);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.EXECUTING     = this.notify.configure(-1, vmm_notify::ON_OFF);\n   this.SUB_EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);\n   this.OBSERVED      = this.notify.configure();\n   this.SUB_OBSERVED  = this.notify.configure();\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (in_chan == null) in_chan = new(\"$1 Input Channel\", inst);\n   this.in_chan = in_chan;\n   if (out_chan == null) out_chan = new(\"$1 Output Channel\", inst);\n   this.out_chan = out_chan;\n   if (exec_chan == null) exec_chan = new(\"$1 Execution Channel\", inst);\n   this.exec_chan = exec_chan;\n   if (obs_chan == null) obs_chan = new(\"$1 Observation Channel\", inst);\n   this.obs_chan = obs_chan;\n\n   if (rx_factory == null) rx_factory = new;\n   this.rx_factory = rx_factory;\n   this.reset_rx_factory = rx_factory;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n                    \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   this.in_chan.flush();\n   this.out_chan.flush();\n   this.exec_chan.flush();\n   this.obs_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n      this.rx_factory = this.reset_rx_factory;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   fork\n      tx_driver();\n      rx_monitor();\n   join\nendtask: main\n\n\ntask $1::tx_driver();\n\n   forever begin\n      hi_transaction_type tr;\n      lo_transaction_type tx[$];\n      bit drop;\n\n      this.wait_if_stopped_or_empty(this.in_chan);\n      this.in_chan.activate(tr);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                     pre_trans(this, tr, drop));\n      if (drop) begin\n         void'(this.in_chan.remove());\n         continue;\n      end\n\n      void'(this.in_chan.start());\n      this.notify.indicate(this.EXECUTING, tr);\n\n      \\`vmm_trace(this.log, \"Starting transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      // ToDo: Turn high-level transaction into a series of\n      //       low-level transactions\n\n      \\`vmm_callback(callback_type,\n                     pre_trans_exec(this, tr, tx));\n\n      foreach (tx[i]) begin\n         drop = 0;\n         \\`vmm_callback(callback_type,\n          pre_exec(this, tx[i], drop));\n         if (drop) continue;\n\n         this.notify.indicate(this.SUB_EXECUTING, tx[i]);\n\n         \\`vmm_debug(this.log, \"Executing lower-level transaction...\");\n         \\`vmm_verbose(this.log, tx[i].psdisplay(\"   \"));\n\n         this.exec_chan.put(tx[i]);\n\n         // ToDo: Add completion model if not blocking\n\n         this.notify.reset(this.SUB_EXECUTING);\n\n         \\`vmm_debug(this.log, \"Executed lower-level transaction...\");\n         \\`vmm_verbose(this.log, tx[i].psdisplay(\"   \"));\n\n         \\`vmm_callback(callback_type,\n            post_exec(this, tx[i]));\n      end // foreach (tx[i])\n\n      \\`vmm_callback(callback_type,\n                     post_trans_exec(this, tr, tx));\n\n      // ToDo: Determine result of high-level transaction from the\n      //       results of the low-level transactions\n\n      this.notify.reset(this.EXECUTING);\n      void'(this.in_chan.complete());\n\n      \\`vmm_trace(this.log, \"Completed transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      \\`vmm_callback(callback_type,\n                     post_in_trans(this, tr));\n\n      void'(this.in_chan.remove());\n   end // forever begin\nendtask: tx_driver\n\n\ntask $1::rx_monitor();\n\n   forever begin\n      hi_transaction_type tr;\n      lo_transaction_type tx[$];\n      lo_transaction_type tmp_tx;\n      bit drop;\n\n      tr = null;\n\n      this.wait_if_stopped_or_empty(this.obs_chan);\n      this.obs_chan.get(tmp_tx);\n      tx.push_back(tmp_tx);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                    post_trans_obs(this, tx[tx.size()-1], drop));\n      if (drop) begin\n         tx.pop_back();\n         continue;\n      end\n\n      this.notify.indicate(this.SUB_OBSERVED, tx[tx.size()-1]);\n\n      \\`vmm_debug(this.log, \"Observed lower-level transaction...\");\n      \\`vmm_verbose(this.log, tx[tx.size()-1].psdisplay(\"   \"));\n\n      // ToDo: Check if the lower-level transactions observed so far\n      //       create a higher-level transaction\n\n      $cast(tr, this.rx_factory.copy());\n\n      if (tr != null) begin\n         drop = 0;\n\n         \\`vmm_callback(callback_type,\n                       post_out_trans(this, tx, tr, drop));\n\n         if (!drop) begin\n            this.notify.indicate(this.OBSERVED, tr);\n\n            \\`vmm_trace(this.log, \"Observed transaction...\");\n            \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n            this.out_chan.sneak(tr);\n         end\n\n         // ToDo: removed the interpreted observed sub transactions\n         tx.delete();\n      end\n   end\nendtask: rx_monitor\n" "VMM Full-Duplex Functional Driver (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant full-duplex functional-level monitor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:TR}         Name of high-level transaction descriptor class\n// ${4:TX}         Name of low-level transaction descriptor class\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$4.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n   // ToDo: Add additional relevant callbacks\n   // ToDo: Use a task if callbacks can be blocking\n\n   // Called at end of observed lower-level transaction\n   virtual function void post_tx_trans_obs(transactor_type xactor,\n                                           lo_transaction_type tx,\n                                           bit drop);\n   endfunction: post_tx_trans_obs\n   virtual function void post_rx_trans_obs(transactor_type xactor,\n                                           lo_transaction_type tx,\n                                           bit drop);\n   endfunction: post_rx_trans_obs\n \n   // Call when a high-level transaction has been identified\n   virtual function void post_tx_trans(transactor_type xactor,\n                                       lo_transaction_type tx[$],\n                                       hi_transaction_type tr,\n                                       bit drop);\n   endfunction: post_tx_trans\n   virtual function void post_rx_trans(transactor_type xactor,\n                                       lo_transaction_type tx[$],\n                                       hi_transaction_type tr,\n                                       bit drop);\n   endfunction: post_rx_trans\nendclass: $1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass: $1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;\n   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int OBS_TX;\n   int SUB_OBS_TX;\n   int OBS_RX;\n   int SUB_OBS_RX;\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n   protected hi_transaction_type tx_factory;\n   local     hi_transaction_type reset_tx_factory;\n   protected hi_transaction_type rx_factory;\n   local     hi_transaction_type reset_rx_factory;\n\n   hi_channel_type tx_chan;\n   hi_channel_type rx_chan;\n   lo_channel_type tx_obs_chan;\n   lo_channel_type rx_obs_chan;\n\n   extern function new (string inst,\n           int stream_id,\n            configuration_type cfg = null,\n            hi_channel_type tx_chan = null,\n           hi_channel_type rx_chan = null,\n           lo_channel_type tx_obs_chan = null,\n           lo_channel_type rx_obs_chan = null,\n           hi_transaction_type tx_factory = null,\n            hi_transaction_type rx_factory = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n   extern protected virtual task tx_monitor();\n   extern protected virtual task rx_monitor();\n\nendclass: $1\n\n\nfunction $1::new(string inst,\n                   int stream_id,\n                   configuration_type cfg,\n                   hi_channel_type tx_chan,\n                   hi_channel_type rx_chan,\n                   lo_channel_type tx_obs_chan,\n                   lo_channel_type rx_obs_chan,\n                   hi_transaction_type tx_factory,\n                   hi_transaction_type rx_factory);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.OBS_TX     = this.notify.configure();\n   this.SUB_OBS_TX = this.notify.configure();\n   this.OBS_RX     = this.notify.configure();\n   this.SUB_OBS_RX = this.notify.configure();\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (tx_chan == null) tx_chan = new(\"$1 Tx Output Channel\", inst);\n   this.tx_chan = tx_chan;\n   if (rx_chan == null) rx_chan = new(\"$1 Rx Output Channel\", inst);\n   this.rx_chan = rx_chan;\n   if (tx_obs_chan == null)\n     tx_obs_chan = new(\"$1 Tx Observation Channel\", inst);\n   this.tx_obs_chan = tx_obs_chan;\n   if (rx_obs_chan == null)\n     rx_obs_chan = new(\"$1 Rx Observation Channel\", inst);\n   this.rx_obs_chan = rx_obs_chan;\n\n   if (tx_factory == null) tx_factory = new;\n   this.tx_factory = tx_factory;\n   this.reset_tx_factory = tx_factory;\n   if (rx_factory == null) rx_factory = new;\n   this.rx_factory = rx_factory;\n   this.reset_rx_factory = rx_factory;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n                   \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   this.tx_chan.flush();\n   this.rx_chan.flush();\n   this.tx_obs_chan.flush();\n   this.rx_obs_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n      this.tx_factory = this.reset_tx_factory;\n      this.rx_factory = this.reset_rx_factory;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   fork\n      tx_monitor();\n      rx_monitor();\n   join\nendtask: main\n\n\ntask $1::tx_monitor();\n\n   forever begin\n      hi_transaction_type tr;\n      lo_transaction_type tx[$];\n      lo_transaction_type tmp_tx;\n      bit drop;\n\n      tr = null;\n\n      this.wait_if_stopped_or_empty(this.tx_obs_chan);\n      this.tx_obs_chan.get(tmp_tx);\n      tx.push_back(tmp_tx);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                    post_tx_trans_obs(this, tx[tx.size()-1], drop));\n      if (drop) begin\n         tx.pop_back();\n         continue;\n      end\n\n      this.notify.indicate(this.SUB_OBS_TX, tx[tx.size()-1]);\n\n      \\`vmm_debug(this.log, \"Observed lower-level Tx transaction...\");\n      \\`vmm_verbose(this.log, tx[tx.size()-1].psdisplay(\"   \"));\n\n      // ToDo: Check if the lower-level transactions observed so far\n      //       create a higher-level transaction\n\n      $cast(tr, this.tx_factory.copy());\n\n      if (tr != null) begin\n         drop = 0;\n\n         \\`vmm_callback(callback_type,\n                       post_tx_trans(this, tx, tr, drop));\n\n         if (!drop) begin\n            this.notify.indicate(this.OBS_TX, tr);\n\n            \\`vmm_trace(this.log, \"Observed transaction...\");\n            \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n            this.tx_chan.sneak(tr);\n         end\n\n         // ToDo: removed the interpreted observed sub transactions\n         tx.delete();\n      end\n   end\nendtask: tx_monitor\n\n\ntask $1::rx_monitor();\n\n   forever begin\n      hi_transaction_type tr;\n      lo_transaction_type tx[$];\n      lo_transaction_type tmp_tx;\n      bit drop;\n\n      tr = null;\n\n      this.wait_if_stopped_or_empty(this.rx_obs_chan);\n      this.rx_obs_chan.get(tmp_tx);\n      tx.push_back(tmp_tx);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                    post_rx_trans_obs(this, tx[tx.size()-1], drop));\n      if (drop) begin\n         tx.pop_back();\n         continue;\n      end\n\n      this.notify.indicate(this.SUB_OBS_RX, tx[tx.size()-1]);\n\n      \\`vmm_debug(this.log, \"Observed lower-level Rx transaction...\");\n      \\`vmm_verbose(this.log, tx[tx.size()-1].psdisplay(\"   \"));\n\n      // ToDo: Check if the lower-level transactions observed so far\n      //       create a higher-level transaction\n\n      $cast(tr, this.rx_factory.copy());\n\n      if (tr != null) begin\n         drop = 0;\n\n         \\`vmm_callback(callback_type,\n                       post_rx_trans(this, tx, tr, drop));\n\n         if (!drop) begin\n            this.notify.indicate(this.OBS_RX, tr);\n\n            \\`vmm_trace(this.log, \"Observed transaction...\");\n            \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n            this.rx_chan.sneak(tr);\n         end\n\n         // ToDo: removed the interpreted observed sub transactions\n         tx.delete();\n      end\n   end\nendtask: rx_monitor\n" "VMM Full-Duplex Functional Monitor (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant full-duplex physical-level transactor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:IF}         Name of physical interface\n// ${4:master}     Name of modport in physical interface\n// ${5:TR}         Name of input/output transaction descriptor class\n//\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$5.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n   // ToDo: Add additional relevant callbacks\n   // ToDo: Use \"function void\" if callbacks cannot be blocking\n\n   // Called before a transaction is executed\n   virtual task pre_ex_trans(transactor_type xactor,\n                             transaction_type tr,\n                             ref bit drop);\n\n   endtask: pre_ex_trans\n\n   // Called after a transaction has been executed\n   virtual task post_ex_trans(transactor_type xactor,\n                              transaction_type tr);\n\n   endtask: post_ex_trans\n\n   // Called at start of observed transaction\n   virtual function void pre_obs_trans(transactor_type xactor,\n                                       transaction_type tr);\n\n   endfunction: pre_obs_trans\n\n   // Called before acknowledging a transaction\n   virtual function void pre_ack(transactor_type xactor,\n                                 transaction_type tr);\n\n   endfunction: pre_ack\n\n   // Called at end of observed transaction\n   virtual function void post_obs_trans(transactor_type xactor,\n                                        transaction_type tr);\n\n   endfunction: post_obs_trans\n\nendclass: $1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass:$1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int EXECUTING;\n   int OBSERVING;\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n   protected transaction_type rx_factory;\n   local     transaction_type reset_rx_factory;\n\n   channel_type in_chan;\n   channel_type out_chan;\n   virtual $3.$4 sigs;\n\n   extern function new(string inst,\n                       int stream_id,\n                       virtual $3.$4 sigs,\n                       configuration_type cfg = null,\n                       channel_type in_chan = null,\n                       channel_type out_chan = null,\n                       transaction_type rx_factory = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n   extern protected virtual task tx_driver();\n   extern protected virtual task rx_monitor();\n\nendclass: $1\n\n\nfunction $1::new(string inst,\n                 int stream_id,\n                 virtual $3.$4 sigs,\n                 configuration_type cfg,\n                 channel_type in_chan,\n                 channel_type out_chan,\n                 transaction_type rx_factory);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);\n   this.OBSERVING = this.notify.configure(-1, vmm_notify::ON_OFF);\n\n\n   this.sigs = sigs;\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (in_chan == null) in_chan = new(\"$1 Input Channel\", inst);\n   this.in_chan = in_chan;\n   if (out_chan == null) out_chan = new(\"$1 Output Channel\", inst);\n   this.out_chan = out_chan;\n\n   if (rx_factory == null) rx_factory = new;\n   this.rx_factory = rx_factory;\n   this.reset_rx_factory = rx_factory;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n                    \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   // ToDo: Reset output/inout signals\n   this.sigs.mck1.sync_txd <= 0;\n   this.sigs.mck1.sync_dat <= 'z;\n   this.sigs.async_en      <= 0;\n\n   this.in_chan.flush();\n   this.out_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n      this.rx_factory = this.reset_rx_factory;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   fork\n      tx_driver();\n      rx_monitor();\n   join\nendtask: main\n\n\ntask $1::tx_driver();\n\n   forever begin\n      transaction_type tr;\n      bit drop;\n\n      // ToDo: Set output/inout signals to their idle state\n      this.sigs.mck1.sync_txd <= 0;\n      this.sigs.async_en      <= 0;\n\n      this.wait_if_stopped_or_empty(this.in_chan);\n      this.in_chan.activate(tr);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                     pre_ex_trans(this, tr, drop));\n      if (drop) begin\n         void'(this.in_chan.remove());\n         continue;\n      end\n\n      void'(this.in_chan.start());\n      this.notify.indicate(this.EXECUTING, tr);\n\n      \\`vmm_trace(this.log, \"Starting Tx transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      case (tr.kind)\n        transaction_type::READ: begin\n           // ToDo: Implement READ transaction\n        end\n\n        transaction_type::WRITE: begin\n           // ToDo: Implement READ transaction\n        end\n      endcase\n\n      this.notify.reset(this.EXECUTING);\n      void'(this.in_chan.complete());\n\n      \\`vmm_trace(this.log, \"Completed Tx transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      \\`vmm_callback(callback_type,\n                     post_ex_trans(this, tr));\n\n      void'(this.in_chan.remove());\n   end\nendtask: tx_driver\n\n\ntask $1::rx_monitor();\n\n   forever begin\n      transaction_type tr;\n\n      // ToDo: Set output signals to their idle state\n      this.sigs.mck1.sync_dat <= 'z;\n\n      // ToDo: Wait for start of transaction\n\n      $cast(tr, this.rx_factory.copy());\n      \\`vmm_callback(callback_type,\n                     pre_obs_trans(this, tr));\n\n      tr.notify.indicate(vmm_data::STARTED);\n      this.notify.indicate(this.OBSERVING, tr);\n\n      \\`vmm_trace(this.log, \"Starting Rx transaction...\");\n\n      // ToDo: Observe first half of transaction\n\n      tr.status = transaction_type::IS_OK;\n      \\`vmm_callback(callback_type,\n                     pre_obs_trans(this, tr));\n\n      // ToDo: React to observed transaction with ACK/NAK\n\n      \\`vmm_trace(this.log, \"Completed Rx transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      this.notify.reset(this.OBSERVING);\n      tr.notify.indicate(vmm_data::ENDED);\n\n      \\`vmm_callback(callback_type,\n                     post_obs_trans(this, tr));\n\n      this.out_chan.sneak(tr);\n   end\nendtask: rx_monitor\n" "VMM Full-Duplex Physical Driver (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant full-duplex physical-level monitor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:IF}         Name of physical interface\n// ${4:passive}    Name of modport in physical interface\n// ${5:TR}         Name of input/output transaction descriptor class\n//\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$5.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n   // ToDo: Add additional relevant callbacks\n   // ToDo: Use a task if callbacks can be blocking\n\n   // Called at start of observed transaction\n   virtual function void pre_tx_trans($1 xactor,\n                   $5 tr);\n   endfunction: pre_tx_trans\n\n   // Called at end of observed transaction\n   virtual function void post_tx_trans($1 xactor,\n                    $5 tr);\n   endfunction: post_tx_trans\n\n   // Called at start of observed transaction\n   virtual function void pre_rx_trans($1 xactor,\n                    $5 tr);\n   endfunction: pre_rx_trans\n\n   // Called at end of observed transaction\n   virtual function void post_rx_trans($1 xactor,\n                    $5 tr);\n   endfunction: post_rx_trans\nendclass:$1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass:$1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int OBS_ON_TX;\n   int OBS_ON_RX;\n\n   protected $1_cfg cfg;\n   local     $1_cfg reset_cfg;\n   protected $5 tx_factory;\n   local     $5 reset_tx_factory;\n   protected $5 rx_factory;\n   local     $5 reset_rx_factory;\n\n   $5_channel tx_chan;\n   $5_channel rx_chan;\n   virtual   $3.$4 sigs;\n\n   extern function new(string inst,\n            int stream_id,\n            virtual $3.$4 sigs,\n               $1_cfg cfg = null,\n            $5_channel tx_chan = null,\n            $5_channel rx_chan = null,\n            $5 tx_factory = null,\n             $5 rx_factory = null);\n\n   extern virtual function void reconfigure($1_cfg cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n   extern protected virtual task tx_monitor();\n   extern protected virtual task rx_monitor();\n\nendclass:$1\n\n\nfunction $1::new(string inst,\n       int stream_id,\n        virtual $3.$4 sigs,\n       $1_cfg cfg,\n       $5_channel tx_chan,\n       $5_channel rx_chan,\n       $5 tx_factory,\n        $5 rx_factory);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.OBS_ON_TX = this.notify.configure(-1, vmm_notify::ON_OFF);\n   this.OBS_ON_RX = this.notify.configure(-1, vmm_notify::ON_OFF);\n\n   this.sigs = sigs;\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (tx_chan == null) tx_chan = new(\"$1 Tx Channel\", inst);\n   this.tx_chan = tx_chan;\n   if (rx_chan == null) rx_chan = new(\"$1 Rx Channel\", inst);\n   this.rx_chan = rx_chan;\n\n   if (tx_factory == null) tx_factory = new;\n   this.tx_factory = tx_factory;\n   this.reset_tx_factory = tx_factory;\n\n   if (rx_factory == null) rx_factory = new;\n   this.rx_factory = rx_factory;\n   this.reset_rx_factory = rx_factory;\nendfunction: new\n\n\nfunction void $1::reconfigure($1_cfg cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n           \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   this.tx_chan.flush();\n   this.rx_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n      this.tx_factory = this.reset_tx_factory;\n      this.rx_factory = this.reset_rx_factory;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   fork\n      tx_monitor();\n      rx_monitor();\n   join\nendtask: main\n\n\ntask $1::tx_monitor();\n\n   forever begin\n      $5 tr;\n\n      // ToDo: Wait for start of transaction\n\n      $cast(tr, this.tx_factory.copy());\n      \\`vmm_callback($1_callbacks,\n            pre_tx_trans(this, tr));\n\n      tr.notify.indicate(vmm_data::STARTED);\n      this.notify.indicate(this.OBS_ON_TX, tr);\n\n      \\`vmm_trace(this.log, \"Starting Tx transaction...\");\n\n      // ToDo: Observe transaction\n\n      \\`vmm_trace(this.log, \"Completed Tx transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      this.notify.reset(this.OBS_ON_TX);\n      tr.notify.indicate(vmm_data::ENDED);\n\n      \\`vmm_callback($1_callbacks,\n           post_tx_trans(this, tr));\n\n      this.tx_chan.sneak(tr);\n   end\nendtask: tx_monitor\n\n\ntask $1::rx_monitor();\n\n   forever begin\n      $5 tr;\n\n      // ToDo: Wait for start of transaction\n\n      $cast(tr, this.rx_factory.copy());\n      \\`vmm_callback($1_callbacks,\n            pre_rx_trans(this, tr));\n\n      tr.notify.indicate(vmm_data::STARTED);\n      this.notify.indicate(this.OBS_ON_RX, tr);\n\n      \\`vmm_trace(this.log, \"Starting Rx transaction...\");\n\n      // ToDo: Observe transaction\n\n      \\`vmm_trace(this.log, \"Completed Tx transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      this.notify.reset(this.OBS_ON_RX);\n      tr.notify.indicate(vmm_data::ENDED);\n\n      \\`vmm_callback($1_callbacks,\n           post_rx_trans(this, tr));\n\n      this.rx_chan.sneak(tr);\n   end\nendtask: rx_monitor\n" "VMM Full-Duplex Physical Monitor (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant half-duplex functional-level transactor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:TR}         Name of high-level transaction descriptor class\n// ${4:TX}         Name of low-level transaction descriptor class\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$4.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n   // ToDo: Add additional relevant callbacks\n   // ToDo: Use a task if callbacks can be blocking\n\n   // Called before a transaction is executed\n   virtual task pre_trans(transactor_type xactor,\n                          hi_transaction_type tr,\n                          bit drop);\n   endtask: pre_trans\n\n   virtual function void pre_trans_exec(transactor_type xactor,\n                                        hi_transaction_type tr,\n                                        lo_transaction_type tx[$]);\n   endfunction: pre_trans_exec\n\n   // Called at start of lower transaction\n   virtual task pre_exec(transactor_type xactor,\n                         lo_transaction_type tx,\n                         bit drop);\n   endtask: pre_exec\n\n   // Called at end of lower transaction\n   virtual task post_exec(transactor_type xactor,\n                          lo_transaction_type tx);\n   endtask: post_exec\n\n   virtual function void post_trans_exec(transactor_type xactor,\n                                         hi_transaction_type tr,\n                                         lo_transaction_type tx[$]);\n   endfunction: post_trans_exec\n\n   // Called after a transaction has been executed\n   virtual task post_trans(transactor_type xactor,\n                           hi_transaction_type tr);\n   endtask: post_trans\nendclass:$1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass: $1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;\n   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int EXECUTING;\n   int SUB_EXECUTING;\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n\n   hi_channel_type in_chan;\n   lo_channel_type exec_chan;\n\n   extern function new(string inst,\n                       int stream_id,\n                       configuration_type cfg = null,\n                       hi_channel_type in_chan = null,\n                       lo_channel_type exec_chan = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n   extern protected virtual task tx_driver();\n\nendclass: $1\n\nfunction $1::new(string inst,\n                 int stream_id,\n                 configuration_type cfg,\n                 hi_channel_type in_chan,\n                 lo_channel_type exec_chan);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.EXECUTING     = this.notify.configure(-1, vmm_notify::ON_OFF);\n   this.SUB_EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (in_chan == null) in_chan = new(\"$1 Input Channel\", inst);\n   this.in_chan = in_chan;\n   if (exec_chan == null) exec_chan = new(\"$1 Execution Channel\", inst);\n   this.exec_chan = exec_chan;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n                    \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   this.in_chan.flush();\n   this.exec_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   fork\n      tx_driver();\n   join\nendtask: main\n\n\ntask $1::tx_driver();\n\n   forever begin\n      hi_transaction_type tr;\n      lo_transaction_type tx[$];\n      bit drop;\n\n      this.wait_if_stopped_or_empty(this.in_chan);\n      this.in_chan.activate(tr);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                     pre_trans(this, tr, drop));\n      if (drop) begin\n         void'(this.in_chan.remove());\n         continue;\n      end\n\n      void'(this.in_chan.start());\n      this.notify.indicate(this.EXECUTING, tr);\n\n      \\`vmm_trace(this.log, \"Starting transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      // ToDo: Turn high-level transaction into a series of\n      //       low-level transactions\n\n      \\`vmm_callback(callback_type,\n                     pre_trans_exec(this, tr, tx));\n\n      foreach (tx[i]) begin\n         drop = 0;\n         \\`vmm_callback(callback_type,\n            pre_exec(this, tx[i], drop));\n         if (drop) continue;\n\n         this.notify.indicate(this.SUB_EXECUTING, tx[i]);\n\n         \\`vmm_debug(this.log, \"Executing lower-level transaction...\");\n         \\`vmm_verbose(this.log, tx[i].psdisplay(\"   \"));\n\n         this.exec_chan.put(tx[i]);\n\n         // ToDo: Add completion model if not blocking\n\n         this.notify.reset(this.SUB_EXECUTING);\n\n         \\`vmm_debug(this.log, \"Executed lower-level transaction...\");\n         \\`vmm_verbose(this.log, tx[i].psdisplay(\"   \"));\n\n         \\`vmm_callback(callback_type,\n            post_exec(this, tx[i]));\n      end // foreach (tx[i])\n\n      \\`vmm_callback(callback_type,\n                     post_trans_exec(this, tr, tx));\n\n      // ToDo: Determine result of high-level transaction from the\n      //       results of the low-level transactions\n\n      this.notify.reset(this.EXECUTING);\n      void'(this.in_chan.complete());\n\n      \\`vmm_trace(this.log, \"Completed transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      \\`vmm_callback(callback_type,\n                     post_trans(this, tr));\n\n      void'(this.in_chan.remove());\n   end // forever begin\nendtask: tx_driver\n" "VMM Half-Duplex Functional Driver (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant half-duplex functional-level monitor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:TR}         Name of high-level transaction descriptor class\n// ${4:TX}         Name of low-level transaction descriptor class\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$4.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n  // ToDo: Add additional relevant callbacks\n  // ToDo: Use a task if callbacks can be blocking\n\n  // Called at end of observed lower-level transaction\n  virtual function void post_trans_obs(transactor_type xactor,\n                      lo_transaction_type tx,\n                       bit drop);\n  endfunction: post_trans_obs\n\n   // Call when a high-level transaction has been identified\n   virtual function post_trans(transactor_type xactor,\n                 lo_transaction_type tx[$],\n                hi_transaction_type tr,\n                   bit drop);\n   endfunction: post_trans\n\nendclass: $1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass: $1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} hi_transaction_type;\n   typedef $4 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} lo_transaction_type;\n   typedef vmm_channel_typed #(hi_transaction_type) hi_channel_type;\n   typedef vmm_channel_typed #(lo_transaction_type) lo_channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int OBSERVED;\n   int SUB_OBSERVED;\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n   protected hi_transaction_type rx_factory;\n   local     hi_transaction_type reset_rx_factory;\n\n   hi_channel_type out_chan;\n   lo_channel_type obs_chan;\n\n\n   extern function new(string inst,\n               int stream_id,\n            configuration_type cfg = null,\n            hi_channel_type out_chan = null,\n              lo_channel_type obs_chan = null,\n              hi_transaction_type rx_factory = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n   extern protected virtual task rx_monitor();\n\nendclass: $1\n\n\nfunction $1::new(string inst,\n         int stream_id,\n        configuration_type cfg,\n       hi_channel_type out_chan,\n         lo_channel_type obs_chan,\n         hi_transaction_type rx_factory);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.OBSERVED = this.notify.configure();\n   this.SUB_OBSERVED = this.notify.configure();\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (out_chan == null) out_chan = new(\"$1 Output Channel\", inst);\n   this.out_chan = out_chan;\n   if (obs_chan == null) obs_chan = new(\"$1 Observation Channel\", inst);\n   this.obs_chan = obs_chan;\n\n   if (rx_factory == null) rx_factory = new;\n   this.rx_factory = rx_factory;\n   this.reset_rx_factory = rx_factory;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n                    \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   this.out_chan.flush();\n   this.obs_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n      this.rx_factory = this.reset_rx_factory;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   fork\n      rx_monitor();\n   join\nendtask: main\n\n\ntask $1::rx_monitor();\n\n   forever begin\n      hi_transaction_type tr;\n      lo_transaction_type tx[$];\n      lo_transaction_type tmp_tx;\n      bit drop;\n\n      tr = null;\n\n      this.wait_if_stopped_or_empty(this.obs_chan);\n      this.obs_chan.get(tmp_tx);\n      tx.push_back(tmp_tx);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n           post_trans_obs(this, tx[tx.size()-1], drop));\n      if (drop) begin\n   tx.pop_back();\n    continue;\n      end\n\n      this.notify.indicate(this.SUB_OBSERVED, tx[tx.size()-1]);\n\n      \\`vmm_debug(this.log, \"Observed lower-level transaction...\");\n      \\`vmm_verbose(this.log, tx[tx.size()-1].psdisplay(\"   \"));\n\n      // ToDo: Check if the lower-level transactions observed so far\n      //       create a higher-level transaction\n\n      $cast(tr, this.rx_factory.copy());\n\n      if (tr != null) begin\n   drop = 0;\n\n   \\`vmm_callback(callback_type,\n              post_trans(this, tx, tr, drop));\n\n  if (!drop) begin\n     this.notify.indicate(this.OBSERVED, tr);\n\n        \\`vmm_trace(this.log, \"Observed transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      this.out_chan.sneak(tr);\n   end // if (!drop)\n\n   // ToDo: removed the interpreted observed sub transactions\n    tx.delete();\n      end // if (tr != null)\n   end // forever begin\nendtask: rx_monitor\n" "VMM Half-Duplex Functional Monitor (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant half-duplex physical-level transactor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:IF}         Name of physical interface\n// ${4:master}     Name of modport in physical interface\n// ${5:TR}         Name of input transaction descriptor class\n//\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$5.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n  // ToDo: Add additional relevant callbacks\n  // ToDo: Use \"function void\" if callbacks cannot be blocking\n\n   // Called before a transaction is executed\n   virtual task pre_trans(transactor_type xactor,\n                          transaction_type tr,\n                          ref bit drop);\n   endtask: pre_trans\n\n   // Called after a transaction has been executed\n   virtual task post_trans(transactor_type xactor,\n                           transaction_type tr);\n   endtask: post_trans\nendclass: $1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass: $1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int EXECUTING;\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n\n   channel_type in_chan;\n   virtual $3.$4 sigs;\n\n   extern function new(string inst,\n                       int stream_id,\n                       virtual $3.$4 sigs,\n                       configuration_type cfg = null,\n                       channel_type in_chan = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n\nendclass: $1\n\n\nfunction $1::new(string inst,\n                 int stream_id,\n                 virtual $3.$4 sigs,\n                 configuration_type cfg,\n                 channel_type in_chan);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.EXECUTING = this.notify.configure(-1, vmm_notify::ON_OFF);\n\n   this.sigs = sigs;\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (in_chan == null) in_chan = new(\"$1 Input Channel\", inst);\n   this.in_chan = in_chan;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n                    \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   // ToDo: Reset output signals\n   this.sigs.mck1.sync_txd <= 0;\n   this.sigs.mck1.sync_dat <= 'z;\n   this.sigs.async_en      <= 0;\n\n   this.in_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   forever begin\n      transaction_type tr;\n      bit drop;\n\n      // ToDo: Set output signals to their idle state\n      this.sigs.mck1.sync_txd <= 0;\n      this.sigs.mck1.sync_dat <= 'z;\n      this.sigs.async_en      <= 0;\n\n      this.wait_if_stopped_or_empty(this.in_chan);\n      this.in_chan.activate(tr);\n\n      drop = 0;\n      \\`vmm_callback(callback_type,\n                     pre_trans(this, tr, drop));\n      if (drop) begin\n         void'(this.in_chan.remove());\n         continue;\n      end\n\n      void'(this.in_chan.start());\n      this.notify.indicate(this.EXECUTING, tr);\n\n      \\`vmm_trace(this.log, \"Starting transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      case (tr.kind)\n         transaction_type::READ: begin\n            // ToDo: Implement READ transaction\n         end\n\n         transaction_type::WRITE: begin\n            // ToDo: Implement WRITE transaction\n         end\n      endcase\n\n      this.notify.reset(this.EXECUTING);\n      void'(this.in_chan.complete());\n\n      \\`vmm_trace(this.log, \"Completed transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      \\`vmm_callback(callback_type,\n                    post_trans(this, tr));\n\n      void'(this.in_chan.remove());\n   end\nendtask: main\n" "VMM Half-Duplex Physical Driver (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant half-duplex physical-level monitor\n//\n// ${1:XACT}       Name of transactor\n// ${2:#(int DW=32, int AW=32)} Parameters\n// ${3:IF}         Name of physical interface\n// ${4:slave}      Name of modport in physical interface\n// ${5:TR}         Name of output transaction descriptor class\n//\n\n\\`include \"vmm.sv\"\n\\`include \"$3.sv\"\n\\`include \"$5.sv\"\n\ntypedef class $1;\n\nclass $1_callbacks $2 extends vmm_xactor_callbacks;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   $0\n   // ToDo: Add additional relevant callbacks\n   // ToDo: Use a task if callbacks can be blocking\n\n   // Called at start of observed transaction\n   virtual function void pre_trans(transactor_type xactor,\n                transaction_type tr);\n   endfunction: pre_trans\n\n   // Called before acknowledging a transaction\n   virtual function pre_ack(transactor_type xactor,\n               transaction_type tr);\n   endfunction: pre_ack\n\n   // Called at end of observed transaction\n   virtual function void post_trans(transactor_type xactor,\n                    transaction_type tr);\n   endfunction: post_trans\n\nendclass: $1_callbacks\n\n\nclass $1_cfg;\n   // ToDo: Add transactor configuration class properties\n   rand int mode;\nendclass: $1_cfg\n\n\nclass $1 $2 extends vmm_xactor;\n\n   typedef $1_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $5 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   typedef $1_cfg configuration_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int OBSERVING;\n\n   protected configuration_type cfg;\n   local     configuration_type reset_cfg;\n   protected transaction_type rx_factory;\n   local     transaction_type reset_rx_factory;\n\n   channel_type out_chan;\n   virtual $3.$4 sigs;\n\n   extern function new(string inst,\n              int stream_id,\n            virtual $3.$4 sigs,\n               configuration_type cfg = null,\n            channel_type out_chan = null,\n             transaction_type rx_factory = null);\n\n   extern virtual function void reconfigure(configuration_type cfg);\n   extern virtual function void reset_xactor(reset_e rst_typ = SOFT_RST);\n   extern protected virtual task main();\n\nendclass: $1\n\n\nfunction $1::new(string inst,\n          int stream_id,\n        virtual $3.$4 sigs,\n           configuration_type cfg,\n           channel_type out_chan,\n        transaction_type rx_factory);\n\n   super.new(\"$1 Transactor\", inst, stream_id);\n\n   this.OBSERVING = this.notify.configure(-1, vmm_notify::ON_OFF);\n\n   this.sigs = sigs;\n\n   if (cfg == null) cfg = new;\n   this.cfg = cfg;\n   this.reset_cfg = cfg;\n\n   if (out_chan == null) out_chan = new(\"$1 Output Channel\", inst);\n   this.out_chan = out_chan;\n\n   if (rx_factory == null) rx_factory = new;\n   this.rx_factory = rx_factory;\n   this.reset_rx_factory = rx_factory;\nendfunction: new\n\n\nfunction void $1::reconfigure(configuration_type cfg);\n\n   if (!this.notify.is_on(XACTOR_IDLE)) begin\n      \\`vmm_warning(this.log,\n       \"Transactor should be reconfigured only when IDLE\");\n   end\n\n   this.cfg = cfg;\n\n   // ToDo: Notify any running threads of the new configuration\nendfunction: reconfigure\n\n\nfunction void $1::reset_xactor(reset_e rst_typ);\n\n   super.reset_xactor(rst_typ);\n\n   // ToDo: Reset output signals\n   this.sigs.sck1.sync_dat <= 'z;\n   this.sigs.sck2.sync_rxd <= 0;\n   this.sigs.async_rdy     <= 0;\n\n   this.out_chan.flush();\n\n   // ToDo: Reset other state information\n\n   if (rst_typ != SOFT_RST) begin\n      // ToDo: Reset state if FIRM or above\n   end\n\n   if (rst_typ == PROTOCOL_RST) begin\n      // ToDo: Reset state if PROTOCOL\n   end\n\n   if (rst_typ == HARD_RST) begin\n      // ToDo: Reset state if HARD or above\n      this.cfg = this.reset_cfg;\n      this.rx_factory = this.reset_rx_factory;\n   end\nendfunction: reset_xactor\n\n\ntask $1::main();\n   super.main();\n\n   forever begin\n      transaction_type tr;\n\n      // ToDo: Set output signals to their idle state\n      this.sigs.sck1.sync_dat <= 'z;\n      this.sigs.sck2.sync_rxd <= 0;\n      this.sigs.async_rdy     <= 0;\n\n      // ToDo: Wait for start of transaction\n\n      $cast(tr, this.rx_factory.copy());\n      \\`vmm_callback(callback_type,\n           pre_trans(this, tr));\n\n      tr.notify.indicate(vmm_data::STARTED);\n      this.notify.indicate(this.OBSERVING, tr);\n\n      \\`vmm_trace(this.log, \"Starting transaction...\");\n\n      // ToDo: Observe first half of transaction\n\n      tr.status = transaction_type::IS_OK;\n      \\`vmm_callback(callback_type,\n         pre_ack(this, tr));\n\n      // ToDo: React to observed transaction with ACK/NAK\n\n      \\`vmm_trace(this.log, \"Completed transaction...\");\n      \\`vmm_debug(this.log, tr.psdisplay(\"   \"));\n\n      this.notify.reset(this.OBSERVING);\n      tr.notify.indicate(vmm_data::ENDED);\n\n      \\`vmm_callback(callback_type,\n         post_trans(this, tr));\n\n      this.out_chan.sneak(tr);\n   end\nendtask: main\n" "VMM Half-Duplex Physical Monitor (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant interface\n//\n// ${1:IF}        Name of physical bus\n//\n\n\\`include \"vmm.sv\"\n\n\n// ToDo: One clock per clock domain\n\ninterface $1(input bit ck1,\n        input bit ck2);\n\n   // ToDo: Define default setup & hold times\n   $0\n   parameter setup_time = 5/*ns*/;\n   parameter hold_time  = 3/*ns*/;\n\n   // ToDo: Define synchronous and asynchronous signals as wires\n\n   wire [15:0] sync_txd;\n   wire [15:0] sync_rxd;\n   wire [15:0] sync_dat;\n\n   logic       async_en;\n   logic       async_rdy;\n\n\n   // ToDo: Define one clocking block per clock domain\n   //       with synchronous signal direction from a\n   //       master perspective\n\n   clocking mck1 @(posedge ck1);\n      default input #setup_time output #hold_time;\n      output sync_txd;\n      inout  sync_dat;\n   endclocking: mck1\n\n   clocking mck2 @(posedge ck2);\n      default input #setup_time output #hold_time;\n      input sync_rxd;\n   endclocking: mck2\n\n\n   // ToDo: Define one clocking block per clock domain\n   //       with synchronous signal direction from a\n   //       slave perspective\n\n   clocking sck1 @(posedge ck1);\n      default input #setup_time output #hold_time;\n      input sync_txd;\n      inout sync_dat;\n   endclocking: sck1\n\n   clocking sck2 @(posedge ck2);\n      default input #setup_time output #hold_time;\n      output sync_rxd;\n   endclocking: sck2\n\n\n   // ToDo: Define one clocking block per clock domain\n   //       with synchronous signal direction from a\n   //       monitor perspective\n\n   clocking pck1 @(posedge ck1);\n      default input #setup_time output #hold_time;\n      input sync_txd;\n      input sync_dat;\n   endclocking: pck1\n\n   clocking pck2 @(posedge ck2);\n      default input #setup_time output #hold_time;\n      input sync_rxd;\n   endclocking: pck2\n\n\n   // ToDo: Define a modport for each master, slave and\n   //       monitor, with appropriate asynchronous signal\n   //       directions and clocking blocks\n\n   modport master(clocking mck1,\n         clocking mck2,\n        output async_en,\n          input  async_rdy);\n\n   modport slave(clocking sck1,\n        clocking sck2,\n        input  async_en,\n      output async_rdy);\n\n   modport passive(clocking pck1,\n         clocking pck2,\n        input async_en,\n           input async_rdy);\nendinterface: $1\n" "VMM Interface (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant RAL-based verification environment\n//\n// ${1:RAL}       Name of top-level RAL model\n// ${2:XACT}      Name of RAL access transactor\n// [filename]  tb_env\n// ${3:tb_env}    Name of the TestBench Environment\n//\n\n\n\\`include \"vmm_ral.sv\"\n\n$0\n// ToDo: Add additional required \\`include directives\n\nclass test_cfg;\n\n   // ToDo: Define test configuration parameters (e.g. how long to run)\n\n   function new();\n   endfunction: new\n\n   function string psdisplay(string prefix = \"\");\n   endfunction\nendclass: test_cfg\n\n\nclass scoreboard;\n   test_cfg cfg;\n   vmm_log  log;\n\n   function new(test_cfg cfg);\n      this.cfg = cfg;\n      this.log = new(\"Scoreboard\", \"\");\n   endfunction: new\n\nendclass\n\n\nclass $3 extends vmm_ral_env;\n   test_cfg cfg;\n\n   $1 ral_model;\n   $2 host;\n\n   // ToDo: Declare transactor instances as data members\n\n   scoreboard sb;\n\n\n   function new();\n      super.new();\n      this.cfg = new;\n      $timeformat(-9, 0, \"ns\", 1);\n\n      this.ral_model = new();\n      super.ral.set_model(this.ral_model);\n   endfunction: new\n\n\n   virtual function void gen_cfg();\n      super.gen_cfg();\n\n      if (!this.cfg.randomize()) begin\n    \\`vmm_fatal(log, \"Failed to randomize test configuration\");\n      end\n   endfunction: gen_cfg\n\n\n   virtual function void build();\n      super.build();\n\n      \\`vmm_note(this.log, this.cfg.psdisplay());\n\n      this.host = new( /* ToDo: Supply suitable arguments */ );\n      super.ral.add_xactor(this.host);\n\n      // ToDo: Instantiate transactors, using XMRs to access interface instances\n      // ToDo: Register any required callbacks\n\n      this.sb = new(this.cfg);\n\n      // ToDo: Start transactors needed to configure the DUT\n      this.host.start_xactor();\n   endfunction: build\n\n\n   virtual task hw_reset();\n      // ToDo: Apply hardware reset to DUT\n   endtask: hw_reset\n\n\n   virtual task cfg_dut();\n      super.cfg_dut();\n\n      // ToDo: Configure DUT\n   endtask: cfg_dut\n\n\n   virtual task start();\n      super.start();\n\n      // ToDo: Start all transactors\n   endtask: start\n\n\n   virtual task wait_for_end();\n      super.wait_for_end();\n\n      // ToDo: Figure out when it is time to end the test\n   endtask: wait_for_end\n\n\n   virtual task stop();\n      super.stop();\n\n      // ToDo: Stop all generators\n\n      // ToDo: Let the DUT drain of all pending data\n   endtask: stop\n\n\n   virtual task cleanup();\n      super.cleanup();\n\n      // ToDo: check that nothing was lost\n   endtask: cleanup\nendclass: $3\n\n" "VMM Ral Env (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for physical access BFM that can be used by RAL\n//\n// ${1:XACT}       Name of physical-level transactor\n// ${2:TR}         Name of physical-level transaction descriptor class\n// ${3:DOM}        Name of domain\n// [filename]   $1_DOM_ral_bfm\n//\n\n\\`include \"$1.sv\"\n\\`include \"vmm_ral.sv\"\n\nclass $1_$3_ral_bfm extends vmm_rw_xactor;\n   $1 bfm;\n\n   function new(string inst,\n      int unsigned stream_id,\n       $1 bfm);\n      super.new(\"$1 RAL Master for $3 domain\", inst, stream_id);\n\n      this.bfm = bfm;\n   endfunction: new\n\n\n   virtual function void start_xactor();\n      super.start_xactor();\n      this.bfm.start_xactor();\n   endfunction\n\n\n   virtual function void stop_xactor();\n      super.stop_xactor();\n      this.bfm.stop_xactor();\n   endfunction\n\n\n   virtual function void reset_xactor(vmm_xactor::reset_e\n                    rst_typ = vmm_xactor::SOFT_RST);\n      super.reset_xactor(rst_typ);\n      this.bfm.reset_xactor(rst_typ);\n   endfunction\n\n\n   virtual task execute_single(vmm_rw_access tr);\n      $2 cyc;\n$0\n      // ToDo: Translate the generic RW into an appropriate RW\n      // for the specified domain\n      cyc = new;\n      if (tr.kind == vmm_rw::WRITE) begin\n    // Write cycle\n    // ...\n      end\n      else begin\n   // Read cycle\n     // ...\n      end\n\n      this.bfm.in_chan.put(cyc);\n\n      // ToDo: Send the result of read cycles back to the RAL\n      if (tr.kind == vmm_rw::READ) begin\n  tr.data = ...\n      end\n   endtask: execute_single\nendclass: $1_$3_ral_bfm\n\n" "VMM Ral Multi-Domain Bfm (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for physical access BFM that can be used by RAL\n//\n// ${1:XACT}       Name of physical-level transactor\n// ${2:TR}         Name of physical-level transaction descriptor class\n// ${3:VIF}        Name of virtual interface used by transactor\n// [filename]   $1_ral_bfm\n//\n\n\\`include \"$1.sv\"\n\\`include \"vmm_ral.sv\"\n\nclass $1_ral_bfm extends vmm_rw_xactor;\n   $1 bfm;\n\n   function new(string inst,\n       int unsigned stream_id,\n       virtual $3 sigs);\n      super.new(\"$1 RAL BFM\", inst, stream_id);\n\n      this.bfm = new(inst, stream_id, sigs);\n   endfunction: new\n\n\n   virtual function void start_xactor();\n      super.start_xactor();\n      this.bfm.start_xactor();\n   endfunction\n\n\n   virtual function void stop_xactor();\n      super.stop_xactor();\n      this.bfm.stop_xactor();\n   endfunction\n\n\n   virtual function void reset_xactor(vmm_xactor::reset_e\n                     rst_typ = vmm_xactor::SOFT_RST);\n      super.reset_xactor(rst_typ);\n      this.bfm.reset_xactor(rst_typ);\n   endfunction\n\n\n   virtual task execute_single(vmm_rw_access tr);\n      $2 cyc;\n$0\n      // ToDo: Translate the generic RW into a simple RW\n      cyc = new;\n      if (tr.kind == vmm_rw::WRITE) begin\n     // Write cycle\n    // ...\n      end\n      else begin\n   // Read cycle\n     // ...\n      end\n\n      this.bfm.in_chan.put(cyc);\n\n      // ToDo: Send the result of read cycles back to the RAL\n      if (tr.kind == vmm_rw::READ) begin\n  tr.data = ...\n      end\n   endtask: execute_single\nendclass: $1_ral_bfm\n\n" "VMM RAL Single-Domain Bfm (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "\\`include \"vmm.sv\"\n\n// ${1:XACTN} -- Name of the transaction descriptor class\n// ${2:#(int DW=32, int AW=32)} -- Transaction Descriptor Class Parameters\n// ${3:GEN} -- Name of the Atomic generator being defined\n$0\nclass $1_scenario $2 extends vmm_scenario; \n\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   typedef $1_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} scenario_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   static vmm_log log = new(\"$1\", \"class\"); \n \n   rand transaction_type items[]; \n        transaction_type using; \n \n   local virtual function string this_class_name(); \n      return \"$1 $2\"; \n   endfunction: this_class_name \n \n   local virtual function vmm_log get_vmm_log(); \n      return this.log; \n   endfunction: get_vmm_log \n \n   local virtual function string __default_name(); \n      return \"Undefined $1 Scenario\"; \n   endfunction: __default_name \n \n   virtual function string psdisplay(string prefix = \"\"); \n      psdisplay = super.psdisplay(prefix); \n      foreach (this.items[i]) begin \n         string pfx; \n         if (this.items[i] == null) continue; \n         $sformat(pfx, \"%s  Item[%0d]: \", prefix, i); \n         psdisplay = {psdisplay, \"n\", this.items[i].psdisplay(pfx)}; \n      end \n      if (this.using != null) begin \n         psdisplay = {psdisplay, \"n\", this.using.psdisplay({prefix, \"  Using: \"})}; \n      end \n      return psdisplay; \n   endfunction: psdisplay \n \n   constraint vmm_scenario_valid_$1 { \n      items.size() == length; \n \n\\`ifdef VMM_SOLVE_BEFORE_SIZE \n      solve length before items.size \\`VMM_SOLVE_BEFORE_OPT; \n\\`endif \n   } \n \n   function new(\\`VMM_SCENARIO_NEW_ARGS); \n      super.new(null \\`VMM_SCENARIO_NEW_CALL); \n      using = null; \n   endfunction: new \n \n   virtual function vmm_data copy(vmm_data to = null); \n      scenario_type cpy; \n \n      if (to == null) cpy = new(); \n      else if (!$cast(cpy, to)) begin \n         \\`vmm_fatal(this.log, {\"Cannot copy to non-$1_scenario instance\"}); \n         return null; \n      end \n \n      void'(super.copy(cpy)); \n      cpy.items = new [this.items.size()]; \n      foreach (this.items[i]) begin \n         if (this.items[i] == null) cpy.items[i] = null; \n         else $cast(cpy.items[i], this.items[i].copy()); \n      end \n      if (this.using == null) cpy.using = null; \n      else $cast(cpy.using, this.using.copy()); \n \n      return cpy; \n   endfunction: copy \n \n   function void allocate_scenario(transaction_type using = null); \n      this.items = new [this.get_max_length()]; \n      foreach (this.items[i]) begin \n         if (using == null) this.items[i] = new; \n         else $cast(this.items[i], using.copy()); \n         \\`VMM_OBJECT_SET_PARENT(this.items[i], this) \n \n         this.items[i].stream_id   = this.stream_id; \n         this.items[i].scenario_id = this.scenario_id; \n         this.items[i].data_id     = i; \n      end \n   endfunction: allocate_scenario \n \n   function void fill_scenario(transaction_type using = null); \n      int i; \n \n      if (this.items.size() < this.get_max_length()) begin \n         this.items = new [this.get_max_length()] (this.items); \n      end \n      foreach (this.items[i]) begin \n         if (this.items[i] != null) continue; \n \n         if (using == null) this.items[i] = new; \n         else $cast(this.items[i], using.copy()); \n         \\`VMM_OBJECT_SET_PARENT(this.items[i], this) \n \n         this.items[i].stream_id   = this.stream_id; \n         this.items[i].scenario_id = this.scenario_id; \n         this.items[i].data_id     = i; \n      end \n   endfunction: fill_scenario \n \n   function void pre_randomize(); \n      this.fill_scenario(this.using); \n   endfunction: pre_randomize \n \n   virtual task apply(channel_type     channel, \n                      ref int unsigned n_insts); \n      int i; \n \n      for (i = 0; i < this.length; i++) begin \n         transaction_type item; \n         $cast(item, this.items[i].copy()); \n\\`ifndef VMM_GRAB_DISABLED \n         channel.put(item,,this); \n\\`else \n         channel.put(item); \n\\`endif \n      end \n \n      n_insts = this.length; \n   endtask: apply \nendclass: $1_scenario\n \n \nclass $1_inject_item_scenario $2 extends $1_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)};\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n \n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   function new(transaction_type obj \\`VMM_DATA_NEW_ARGS); \n      super.new(\\`VMM_DATA_NEW_CALL); \n \n      this.items    = new [1]; \n      this.items[0] = obj; \n      this.length   = 1; \n      this.repeated = 0; \n      void'(this.define_scenario(\"Directed 'inject_obj()' transaction\", 1)); \n   endfunction: new \n \n   virtual task apply(channel_type     channel, \n                      ref int unsigned n_insts); \n\\`ifndef VMM_GRAB_DISABLED \n      channel.put(this.items[0],,this); \n\\`else \n      channel.put(this.items[0]); \n\\`endif \n      n_insts = 1; \n   endtask: apply \n \nendclass: $1_inject_item_scenario\n \n \nclass $1_atomic_scenario $2 extends $1_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)}; \n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n \n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int unsigned ATOMIC; \n \n   constraint atomic_scenario { \n      if (scenario_kind == ATOMIC) { \n         length == 1; \n         repeated == 0; \n      } \n   } \n \n   function new(\\`VMM_DATA_NEW_ARGS); \n      super.new(\\`VMM_DATA_NEW_CALL); \n \n      this.ATOMIC = this.define_scenario(\"Atomic\", 1); \n \n      this.scenario_kind   = this.ATOMIC; \n      this.length = 1; \n   endfunction: new \n \n   virtual function string psdisplay(string prefix = \"\"); \n      psdisplay = super.psdisplay(prefix); \n   endfunction:psdisplay \n \n   function void pre_randomize(); \n      super.pre_randomize(); \n   endfunction \n \n   virtual task apply(channel_type     channel, \n                      ref int unsigned n_insts); \n      super.apply(channel, n_insts); \n   endtask: apply \n \nendclass: $1_atomic_scenario\n \n \nclass $1_scenario_election $2; \n   typedef $1_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} scenario_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int stream_id; \n   int scenario_id; \n   int unsigned n_scenarios; \n   int unsigned last_selected[$]; \n   int unsigned next_in_set; \n \n   scenario_type scenario_set[$]; \n \n   rand int select; \n \n   constraint vmm_scenario_election_valid_$1 { \n      select >= 0; \n      select < n_scenarios; \n   } \n \n   constraint round_robin { \n      select == next_in_set; \n   } \n \nendclass: $1_scenario_election\n \ntypedef class $3; \n \nclass $3_callbacks $2 extends vmm_xactor_callbacks; \n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $1_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} scenario_type;\n\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   virtual task pre_scenario_randomize(transactor_type gen, \n                                       ref scenario_type scenario); \n   endtask \n \n   virtual task post_scenario_gen(transactor_type gen, \n                                  scenario_type scenario, \n                                  ref bit dropped); \n   endtask \nendclass: $3_callbacks\n \n \nclass $3 $2 extends vmm_xactor; \n \n   typedef $3 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transactor_type;\n   typedef $1_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} scenario_type;\n   typedef $3_callbacks ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} callback_type;\n   typedef $1_scenario_election ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} election_type;\n   typedef $1_atomic_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} atomic_scenario_type;\n   typedef $1_inject_item_scenario ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} inject_item_scenario_type;\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   \n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n\n   int unsigned stop_after_n_insts; \n   int unsigned stop_after_n_scenarios; \n \n   typedef enum int {GENERATED, \n                     DONE} symbols_e; \n \n   election_type select_scenario; \n \n   scenario_type scenario_set[$]; \n   protected scenario_type scenario_registry[string]; \n \n   channel_type out_chan; \n \n   protected int scenario_count; \n   protected int inst_count; \n \n   virtual function string psdisplay(string prefix = \"\"); \n      psdisplay = super.psdisplay(prefix); \n      $sformat(psdisplay, \"%s [stops after #insts %0d>%0d or #scenarios %0d>%0d]\", \n               psdisplay, this.inst_count, this.stop_after_n_insts, \n               this.scenario_count, this.stop_after_n_scenarios); \n      $sformat(psdisplay, \"%sn%sOutChan: %s(%s) [level=%0d of %0d]\", \n               psdisplay, prefix, this.out_chan.log.get_name(), \n               this.out_chan.log.get_instance(), this.out_chan.level(), \n               this.out_chan.full_level()); \n      foreach (this.scenario_registry[name]) begin \n         psdisplay = {psdisplay, \"n\", \n                      this.scenario_registry[name].psdisplay(prefix)}; \n      end \n      return psdisplay; \n   endfunction: psdisplay \n \n   function new(string       inst, \n                int          stream_id = -1, \n                channel_type out_chan  = null \n                \\`VMM_XACTOR_NEW_ARGS); \n      super.new(\"$1 Scenario Generator\", inst, stream_id \n                \\`VMM_XACTOR_NEW_CALL); \n \n      if (out_chan == null) begin \n         out_chan = new(\"$1 Scenario Generator output channel\", \n                        inst); \n         \\`VMM_OBJECT_SET_PARENT(out_chan, this) \n      end \n      this.out_chan = out_chan; \n      this.out_chan.set_producer(this); \n      this.log.is_above(this.out_chan.log); \n \n      this.scenario_count = 0; \n      this.inst_count = 0; \n      this.stop_after_n_insts     = 0; \n      this.stop_after_n_scenarios = 0; \n \n      this.select_scenario = new; \n      begin \n         atomic_scenario_type sc = new; \n         \\`VMM_OBJECT_SET_PARENT(sc, this) \n         this.register_scenario(\"Atomic\", sc); \n      end \n \n      void'(this.notify.configure(GENERATED)); \n      void'(this.notify.configure(DONE, vmm_notify::ON_OFF)); \n   endfunction: new \n \n   virtual function void register_scenario(string name, \n                                           scenario_type scenario); \n      if(name == \"\") begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"Invalid '%s' string was passed\", name)); \n         return; \n      end \n\n      if(this.scenario_registry.exists(name)) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"%s already has an entry in the scenario registry\", name)); \n         return; \n      end \n\n      if(scenario == null) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"scenario passed for %s is a null value\", name)); \n         return; \n      end \n\n      this.scenario_registry[name] = scenario; \n\n      foreach(this.scenario_set[i]) begin \n         if(this.scenario_set[i] == scenario) \n            return; \n      end \n      this.scenario_set.push_back(scenario); \n   endfunction: register_scenario \n\n   virtual function bit scenario_exists(string name); \n        if(name == \"\") begin \n            \\`vmm_error(this.log, \\`vmm_sformatf(\"Invalid '%s' string was passed\", name)); \n            return 0; \n        end \n\n        if(this.scenario_registry.exists(name)) \n            scenario_exists = 1; \n        else \n            scenario_exists = 0; \n    endfunction: scenario_exists \n\n   virtual function void replace_scenario(string name, \n                                           scenario_type scenario); \n      if(name == \"\") begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"Invalid '%s' string was passed\", name)); \n         return; \n      end \n\n      if(scenario == null) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"scenario passed for %s is a null value\", name)); \n         return; \n      end \n\n      if(!this.scenario_registry.exists(name)) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"cannot replace a unregistered %s entry [use register_scenario]\", name)); \n         return ; \n      end \n\n      foreach(this.scenario_set[i]) begin \n         if(this.scenario_set[i] == this.scenario_registry[name]) begin \n            this.scenario_set.delete(i); \n            break; \n         end \n      end \n      this.scenario_registry[name] = scenario; \n      foreach(this.scenario_set[i]) begin \n          if(this.scenario_set[i] == scenario) \n              return; \n      end \n      this.scenario_set.push_back(scenario); \n   endfunction: replace_scenario \n\n   virtual function void get_all_scenario_names(ref string name[$]); \n      string s; \n\n      if(this.scenario_registry.first(s)) begin \n         do begin \n            name.push_back(s); \n         end while(this.scenario_registry.next(s)); \n      end \n      if(name.size() == 0) begin \n         \\`vmm_warning(this.log, \"There are no entries in the scenario generator registry\"); \n      end \n   endfunction: get_all_scenario_names \n\n   virtual function void get_names_by_scenario(scenario_type scenario, \n                                               ref string name[$]); \n      string s; \n\n      if(scenario == null) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"scenario is a null value\")); \n         return; \n      end \n\n      if(this.scenario_registry.first(s)) begin \n         do begin \n            if(this.scenario_registry[s] == scenario) \n               name.push_back(s); \n         end while(this.scenario_registry.next(s)); \n      end \n      if(name.size() == 0) begin \n         \\`vmm_warning(this.log, \"There are no entries in the scenario registry\"); \n      end \n   endfunction: get_names_by_scenario \n\n   virtual function string get_scenario_name(scenario_type scenario); \n        string s[$]; \n\n        if(scenario == null) begin \n            \\`vmm_error(this.log, \\`vmm_sformatf(\"scenario is a null value\")); \n            return \"\"; \n        end \n\n        this.get_names_by_scenario(scenario, s); \n\n        if(s.size()) \n            get_scenario_name = s[0]; \n        else \n            get_scenario_name = \"\"; \n   endfunction: get_scenario_name \n\n   virtual function int get_scenario_index(scenario_type scenario); \n       get_scenario_index = -1; \n       foreach(this.scenario_set[i]) begin \n          if(this.scenario_set[i] == scenario) begin \n             return i; \n          end \n       end \n       if(get_scenario_index == -1) begin \n          \\`vmm_warning(this.log, \\`vmm_sformatf(\"Cannot find the index for the scenario\")); \n       end \n   endfunction: get_scenario_index \n\n   virtual function bit unregister_scenario(scenario_type scenario); \n      string s; \n      unregister_scenario=0; \n\n      if(scenario == null) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"scenario is a null value\")); \n         return 0; \n      end \n      if(this.scenario_registry.first(s)) begin \n         do begin \n            if(this.scenario_registry[s] == scenario) begin \n               this.scenario_registry.delete(s); \n               unregister_scenario=1; \n            end \n         end while(this.scenario_registry.next(s)); \n      end \n      if(unregister_scenario==0) begin \n         \\`vmm_warning(this.log, \"There are no entries in the scenario registry\"); \n      end \n      if(unregister_scenario) begin \n         foreach(this.scenario_set[i]) begin \n            if(this.scenario_set[i] == scenario) begin \n               this.scenario_set.delete(i); \n               break; \n            end \n         end \n      end \n   endfunction: unregister_scenario \n\n   virtual function scenario_type unregister_scenario_by_name(string name); \n      if(name == \"\") begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"Invalid '%s' string was passed\", name)); \n         return null; \n      end \n      if(!this.scenario_registry.exists(name)) begin \n         \\`vmm_warning(this.log, \\`vmm_sformatf(\"There is no entry for %s in the scenario registry\", name)); \n         return null; \n      end \n      else begin \n         unregister_scenario_by_name = this.scenario_registry[name]; \n         foreach(this.scenario_set[i]) begin \n            if(this.scenario_set[i] == this.scenario_registry[name]) begin \n               this.scenario_set.delete(i); \n               break; \n            end \n         end \n         this.scenario_registry.delete(name); \n      end \n   endfunction: unregister_scenario_by_name \n\n   virtual function scenario_type get_scenario(string name); \n      if(name == \"\") begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"Invalid '%s' string was passed\", name)); \n         return null; \n      end \n      if(!this.scenario_registry.exists(name)) begin \n         \\`vmm_error(this.log, \\`vmm_sformatf(\"%s does not have an entry in the scenario registry\", name)); \n         return null; \n      end \n\n      get_scenario = this.scenario_registry[name]; \n      if(get_scenario == null) \n         \\`vmm_warning(this.log, \\`vmm_sformatf(\"%s has a null scenario associated with it in the scenario registry\", name)); \n\n   endfunction: get_scenario \n \n   function int unsigned get_n_insts(); \n      get_n_insts = this.inst_count; \n   endfunction: get_n_insts \n \n   function int unsigned get_n_scenarios(); \n      get_n_scenarios = this.scenario_count; \n   endfunction: get_n_scenarios \n \n   virtual task inject_obj(transaction_type obj); \n      inject_item_scenario_type scenario = new(obj); \n      this.inject(scenario); \n   endtask: inject_obj \n \n   virtual task inject(scenario_type scenario); \n      bit drop = 0; \n \n      scenario.stream_id   = this.stream_id; \n      scenario.scenario_id = this.scenario_count; \n      foreach (scenario.items[i]) begin \n         scenario.items[i].stream_id   = scenario.stream_id; \n         scenario.items[i].scenario_id = scenario.scenario_id; \n         scenario.items[i].data_id     = i; \n      end \n \n      \\`vmm_callback(callback_type, \n                    post_scenario_gen(this, scenario, drop)); \n \n      if (!drop) begin \n         this.scenario_count++; \n         this.notify.indicate(GENERATED, scenario); \n \n         if (scenario.repeated > scenario.repeat_thresh) begin \n            \\`vmm_warning(this.log, \\`vmm_sformatf(\"A scenario will be repeated %0d times...\", \n                                                 scenario.repeated)); \n         end \n         repeat (scenario.repeated + 1) begin \n            int unsigned n_insts = 0; \n            scenario.apply(this.out_chan, n_insts); \n            this.inst_count += n_insts; \n         end \n      end \n   endtask: inject \n \n   virtual function void reset_xactor(vmm_xactor::reset_e rst_typ = SOFT_RST); \n      super.reset_xactor(rst_typ); \n      this.scenario_count = 0; \n      this.inst_count     = 0; \n      this.out_chan.flush(); \n      \\`vmm_delQ(this.select_scenario.last_selected); \n \n      if (rst_typ >= FIRM_RST) begin \n         this.notify.reset( , vmm_notify::HARD); \n      end \n \n      if (rst_typ >= HARD_RST) begin \n         atomic_scenario_type sc = new; \n         \\`VMM_OBJECT_SET_PARENT(sc, this) \n \n         this.stop_after_n_insts     = 0; \n         this.stop_after_n_scenarios = 0; \n         this.select_scenario = new; \n         this.scenario_set.push_back(sc); \n      end \n \n   endfunction: reset_xactor \n \n   virtual protected task main(); \n      scenario_type the_scenario; \n \n      fork \n         super.main(); \n      join_none \n \n      if(this.scenario_set.size() == 0) \n          return; \n \n      while ((this.stop_after_n_insts <= 0 \n              || this.inst_count < this.stop_after_n_insts) \n             && (this.stop_after_n_scenarios <= 0 \n                 || this.scenario_count < this.stop_after_n_scenarios)) begin \n \n         this.wait_if_stopped(); \n \n         this.select_scenario.stream_id    = this.stream_id; \n         this.select_scenario.scenario_id  = this.scenario_count; \n         this.select_scenario.n_scenarios  = this.scenario_set.size(); \n         this.select_scenario.scenario_set = this.scenario_set; \n         if (this.select_scenario.last_selected.size() == 0) \n            this.select_scenario.next_in_set = 0; \n         else \n            this.select_scenario.next_in_set = ((this.select_scenario.last_selected[$] + 1) % this.scenario_set.size()); \n \n         if (!this.select_scenario.randomize()) begin \n            \\`vmm_fatal(this.log, \"Cannot select scenario descriptor\"); \n            continue; \n         end \n \n         if (this.select_scenario.select < 0 || \n             this.select_scenario.select >= this.scenario_set.size()) begin \n            \\`vmm_fatal(this.log, \\`vmm_sformatf(\"Select scenario #%0d is not within available set (0-%0d)\", \n                                               this.select_scenario.select, \n                                               this.scenario_set.size()-1)); \n            continue; \n         end \n \n         this.select_scenario.last_selected.push_back(this.select_scenario.select); \n         while (this.select_scenario.last_selected.size() > 10) begin \n            void'(this.select_scenario.last_selected.pop_front()); \n         end \n \n         the_scenario = this.scenario_set[this.select_scenario.select]; \n         if (the_scenario == null) begin \n            \\`vmm_fatal(this.log, \\`vmm_sformatf(\"Selected scenario #%0d does not exist\", \n                                               this.select_scenario.select)); \n            continue; \n         end \n \n         the_scenario.stream_id   = this.stream_id; \n         the_scenario.scenario_id = this.scenario_count; \n         foreach (the_scenario.items[i]) begin \n            if (the_scenario.items[i] == null) continue; \n \n            the_scenario.items[i].stream_id   = the_scenario.stream_id; \n            the_scenario.items[i].scenario_id = the_scenario.scenario_id; \n            the_scenario.items[i].data_id     = i; \n         end \n \n         \\`vmm_callback(callback_type, \n                       pre_scenario_randomize(this, the_scenario)); \n         if (the_scenario == null) continue; \n \n         if (!the_scenario.randomize()) begin \n            \\`vmm_fatal(this.log, $psprintf(\"Cannot randomize scenario descriptor #%0d\", \n                                           this.select_scenario.select)); \n            continue; \n         end \n \n         this.inject(the_scenario); \n      end \n \n      this.notify.indicate(DONE); \n      this.notify.indicate(XACTOR_STOPPED); \n      this.notify.indicate(XACTOR_IDLE); \n      this.notify.reset(XACTOR_BUSY); \n      this.scenario_count++; \n   endtask: main \n  \nendclass: $3\n" "VMM Scenario Gen (vmm version 1.1.1)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant testcase\n//\n// ${1:TB_ENV}   Name of verification environment\n// [filename] test_$1\n//\n\n\\`include \"$1.sv\"\n\nprogram test;\n\n   vmm_log log = new(\"Test\", \"Main\");\n   $1 env = new;\n   $0\n   // ToDo: Declare and implement callback extensions, if needed\n\n   initial\n     begin\n    // ToDo: Set configuration parameters and turn rand mode OFF, if needed\n\n env.build();\n\n    // ToDo: Set message service interface verbosity, if needed\n\n // ToDo: Replace factory instances, if needed\n\n   env.start();\n\n    fork\n     begin\n        // ToDo: Directed stimulus, if needed\n      end\n    join_none\n\n   env.run();\n     end\n\nendprogram: test\n" "VMM Testbench Env (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant testcase\n//\n// ${1:TB_ENV}   Name of verification environment\n// [filename] test_$1\n//\n\n\\`include \"$1.sv\"\n\nprogram test;\n\n   vmm_log log = new(\"Test\", \"Main\");\n   $1 env = new;\n\n   // ToDo: Declare and implement callback extensions, if needed\n   $0\n   initial\n     begin\n    // ToDo: Set configuration parameters and turn rand mode OFF, if needed\n\n env.build();\n\n    // ToDo: Set message service interface verbosity, if needed\n\n // ToDo: Replace factory instances, if needed\n\n   env.start();\n\n    fork\n     begin\n        // ToDo: Directed stimulus, if needed\n      end\n    join_none\n\n   env.run();\n     end\n\nendprogram: test\n" "VMM Testcase (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for VMM-compliant transaction descriptor\n//\n// ${1:TR} -- Name of transaction descriptor class\n// ${2:#(int DW=32, int AW=32)} -- transaction descriptor class parameters\n//\n\n\\`include \"vmm.sv\"\n\nclass $1 $2 extends vmm_data;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\([^,)]+\\\\\\\\)\\\\\\\\(,?\\\\\\\\)\" \"\\\\\\\\2\\\\\\\\4\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   // static defines and typedefs to make parameters available as object members\n   ${2:$(let* ((text (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))\n           (params (split-string text \",\")))\n      (mapconcat\n     (lambda (param)\n         (let* ((ss (split-string param)))\n           (cond\n      ((string= (car ss) \"type\") \n      (replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=.*\"\n                     \"typedef \\\\\\\\2_type \\\\\\\\2;\" param))\n      (t\n         (replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=.*\"\n                     \"static \\\\\\\\1 const \\\\\\\\2_VALUE = \\\\\\\\2;\" param)))))\n    params \"\\n   \"))}\n\n   static vmm_log log = new(\"$1\", \"class\");\n\n   // ToDo: Modify/add symbolic transaction identifiers to match\n$0\n   typedef enum {READ, WRITE } kinds_e;\n   rand kinds_e kind;\n\n   // ToDo: Add relevant class properties to define all transactions\n\n   // ToDo: Modify/add symbolic transaction identifiers to match\n   typedef enum {IS_OK, ERROR} status_e;\n   rand status_e status;\n\n   constraint $1_valid {\n      // ToDo: Define constraint to make descriptor valid\n      status == IS_OK;\n   }\n\n   // ToDo: Add constraint blocks to prevent error injection\n\n   function new();\n      super.new(this.log);\n   endfunction: new\n\n   extern virtual function string psdisplay(string prefix = \"\");\n   extern virtual function bit is_valid(bit silent = 1,\n                 input int kind   = -1);\n   extern virtual function vmm_data allocate();\n   extern virtual function vmm_data copy(vmm_data cpy = null);\n   extern virtual function bit compare(vmm_data to,\n                    output string diff,\n                       input int kind = -1);\n   extern virtual function int unsigned byte_size(int kind = -1);\n   extern virtual function int unsigned\n     byte_pack(ref logic [7:0]    bytes[],\n         input int unsigned offset = 0,\n        input int kind   = -1);\n   extern virtual function int unsigned\n     byte_unpack(const ref logic [7:0] bytes[],\n       input int unsigned offset = 0,\n        input int len    = -1,\n        input int kind   = -1);\n\nendclass: $1\n\nfunction string $1::psdisplay(string prefix = \"\");\n\n   // ToDo: Implement this method\n\nendfunction: psdisplay\n\nfunction bit $1::is_valid(bit silent = 1,\n                 input int kind   = -1);\n\n   // ToDo: Implement this method\n\nendfunction: is_valid\n\nfunction vmm_data allocate();\n   transaction_type tr = new;\n   allocate = tr;\nendfunction: allocate\n\nfunction vmm_data $1::copy(vmm_data cpy = null);\n\n   transaction_type to;\n\n   // Copying to a new instance?\n   if (cpy == null)\n    to = new;\n   else\n    // Copying to an existing instance. Correct type?\n if (!$cast(to, cpy)) begin\n       \\`vmm_fatal(this.log, \"Attempting to copy to a non $1 instance\");\n      return null;\n   end\n\n   super.copy_data(to);\n\n   to.kind = this.kind;\n\n   // ToDo: Copy additional class properties\n\n   copy = to;\n\nendfunction: copy\n\nfunction bit $1::compare(vmm_data to,\n           output string diff,\n           input int kind = -1);\n\n   transaction_type tr;\n\n   compare = 0;\n   if (to == null) begin\n     \\`vmm_fatal(this.log, \"Cannot compare to NULL instance\");\n  return 0;\n   end\n\n   if (!$cast(tr,to)) begin\n  \\`vmm_fatal(this.log, \"Attempting to compare to a non $1 instance\");\n   return 0;\n   end\n\n   if (this.kind != tr.kind) begin\n   $sformat(diff, \"Kind %0s != %0s\", this.kind, tr.kind);\n  return 0;\n   end\n   // ToDo: Compare additional class properties\n\n   compare = 1;\n\nendfunction: compare\n\nfunction int unsigned $1::byte_size(int kind = -1);\n\n   // ToDo: Implement this method\n\nendfunction: byte_size\n\nfunction int unsigned\n  $1::byte_pack(ref logic [7:0]    bytes[],\n        input int unsigned offset = 0,\n        input int kind   = -1);\n\n   // ToDo: Implement this method\n\nendfunction: byte_pack\n\nfunction int unsigned\n  $1::byte_unpack(const ref logic [7:0] bytes[],\n       input int unsigned offset = 0,\n        input int len    = -1,\n        input int kind   = -1);\n\n   // ToDo: Implement this method\n\nendfunction: byte_unpack\n\n\\`vmm_channel($1)\n\\`vmm_atomic_gen($1, \"$1\")\n\\`vmm_scenario_gen($1, \"$1\")\n" "VMM Transaction (vmmgen version)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "//\n// Template for testing the implementation of a VMM-compliant\n// transaction descriptor\n//\n// % vcs -R -sverilog -ntb_opts rvm TR_test.sv\n//\n// ${1:TR}         Name of transaction descriptor class\n// [filename]   $1_test\n//\n\nprogram test;\n\n\\`include \"vmm.sv\"\n\\`include \"$1.sv\"\n   $0\n   initial begin\n      vmm_log log = new(\"$1\", \"Descriptor Test\");\n      $1 obj = new;\n      $1 cpy;\n      $1 sb[$];\n      logic [7:0] bytes[];\n      string diff;\n      int n, m;\n      int fp;\n\n      fp = $fopen(\"$1.sav\", \"wb\");\n      if (fp == 0) \\`vmm_fatal(log, \"Cannot open file '$1.sav'\");\n\n      repeat (100) begin\n     if (!obj.randomize()) begin\n      \\`vmm_error(log, \"Failed to randomize object\");\n        obj.display(\"Contradiction: \");\n  end\n   else obj.display(\"\");\n\n     if (!obj.is_valid()) begin\n       \\`vmm_error(log, \"$1::is_valid() did not validate random value\");\n      obj.display(\"Invalid: \");\n    end\n\n     if (!$cast(cpy, obj.allocate())) begin\n       \\`vmm_error(log, \"$1::allocate() did not allocate a $1 instance\");\n     cpy.display(\"Allocated: \");\n  end\n\n     if (cpy.log != obj.log) begin\n        \\`vmm_error(log, \"$1::log is not a static data member\");\n       \\`vmm_note(obj.log, \"Original message interface\");\n     \\`vmm_note(cpy.log, \"Copy message interface\");\n  end\n\n     if (!$cast(cpy, obj.copy())) begin\n       \\`vmm_error(log, \"$1::copy() did not allocate a $1 instance\");\n     cpy.display(\"Allocated: \");\n  end\n   if (!cpy.compare(obj, diff)) begin\n       \\`vmm_error(log, {\"$1::copy() did not new-copy/compare: \", diff});\n     cpy.display(\"Copy: \");\n   end\n\n     cpy = new;\n    obj.copy(cpy);\n    if (!cpy.compare(obj, diff)) begin\n       \\`vmm_error(log, {\"$1::copy() did not copy/compare: \", diff});\n     cpy.display(\"Copy: \");\n   end\n\n\\`ifndef NO_PACKING\n   cpy = new;\n    bytes = new[0];\n   n = obj.byte_pack(bytes);\n     m = obj.byte_size();\n  if (n != m) begin\n        \\`vmm_error(log, $psprintf(\"$1::byte_pack() did not pack $1::byte_size() number of bytes: %d vs. %d\", n, m));\n   end\n\n     m = cpy.byte_unpack(bytes);\n   if (n != m) begin\n        \\`vmm_error(log, $psprintf(\"$1::byte_pack()/byte_unpack() did not pack then unpack same number of bytes: %d then %d\", n, m));\n   end\n\n     if (!cpy.compare(obj, diff)) begin\n       \\`vmm_error(log, {\"$1::byte_pack()/byte_unpack() did not pack/unpack/compare: \", diff});\n       cpy.display(\"Copy: \");\n   end\n\n     cpy.save(fp);\n     sb.push_back(cpy);\n    $write(\"------------------------------------\\n\");\n      end // repeat (100)\n\n      $fclose(fp);\n\n      fp = $fopen(\"$1.sav\", \"rb\");\n      if (fp == 0) \\`vmm_fatal(log, \"Cannot re-open file '$1.sav'\");\n\n      repeat (100) begin\n  if (!obj.load(fp)) \\`vmm_error(log, \"Error occured while loading object\");\n     obj.display(\"Loaded: \");\n    cpy = sb.pop_front();\n     if (!cpy.compare(obj, diff)) begin\n       \\`vmm_error(log, {\"$1::save()/load() did not save/load/compare: \", diff});\n     cpy.display(\"Saved: \");\n  end\n   $write(\"------------------------------------\\n\");\n      end // repeat (100)\n\\`endif\n\n      log.report();\n   end // initial begin\n\nendprogram: test\n" "VMM Transaction Test (vmmgen)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("vmm" "// ${1:name_xactn} -- name of the transaction\n// ${2:#(int DW=32, int AW=32)} -- transaction descriptor class parameters\n\nclass $1 $2 extends vmm_data;\n   // some typedefs to ease up parameters usage\n   typedef $1 ${2:$(replace-regexp-in-string \"\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\" \"\\\\\\\\1\" text)} transaction_type;\n   typedef vmm_channel_typed #(transaction_type) channel_type;\n   // static defines to make parameters available as object members\n   ${2:$(replace-regexp-in-string \"\\\\\\\\s-*\\\\\\\\(\\\\\\\\(?:\\\\\\\\w+\\\\\\\\s-+\\\\\\\\)+\\\\\\\\)\\\\\\\\(\\\\\\\\w+\\\\\\\\)\\\\\\\\s-*=\\\\\\\\s-*\\\\\\\\w+\\\\\\\\s-*,?\" \"const static \\\\\\\\1 \\\\\\\\2_VALUE = \\\\\\\\2;\n   \" (replace-regexp-in-string \"#(\\\\\\\\(.*\\\\\\\\))\" \"\\\\\\\\1\" text))}\n   static vmm_log log = new(\"$1\", \"class\");\n\n   // ToDo: Modify/add symbolic transaction identifiers to match\n$0\n   typedef enum {READ, WRITE } kinds_e;\n   rand kinds_e kind;\n\n   // vmm rule 4-59: All class properties corresponding to a\n   // protocol property or field shall have the rand attribute\n\n   // use rand snippet to define attributes with constraints :)\n   // rand ....\n\n   // transaction time\n   time xactn_time;\n\n   function new();\n      super.new(this.log);\n   endfunction: new\n\n   // VMM 4-76: All classes derived from the vmm_data class shall provide\n   // implementations for the psdisplay(), is_valid(), allocate(), copy() and\n   // compare() virtual methods.\n   extern virtual function string psdisplay(string prefix = \"\");\n\n   extern virtual function bit is_valid(bit silent = 1, int kind = -1);\n\n   extern virtual function vmm_data allocate();\n\n   extern virtual function vmm_data copy(vmm_data to=null);\n\n   extern virtual function bit compare(vmm_data to,\n                      output string diff,\n                       input int kind = -1);\n\n   // VMM 4-77: All classes derived from the vmm_data class should provide\n   // implementations for the byte_size(), byte_pack() and byte_unpack() virtual\n   // methods.\n   extern virtual function int unsigned byte_size(input int kind = -1);\n\n   extern virtual function int unsigned byte_pack(ref logic[7:0] bytes[],\n                          input int unsigned\n                              offset = 0,\n                         input int kind = -1);\n\n   extern virtual function int unsigned byte_unpack(const ref logic[7:0]\n                                 bytes[],\n                            input int unsigned\n                                  offset = 0,\n                         input int len = -1,\n                           input int kind = -1);\n\n   // Pre-Randomize function. Add initialization of dynamic arrays here -- when\n   // initializing, make there size maximum possible.\n   function void pre_randomize();\n      super.pre_randomize();\n   endfunction // pre_randomize\n\n   // Post-Randomize -- initialize the data which gets its value from the\n   // randomized fields -- for example the CRC\n   function void post_randomize();\n      super.post_randomize();\n   endfunction // post_randomize\n\nendclass: $1\n\nfunction vmm_data $1::allocate();\n      transaction_type tr = new;\n      return tr;\nendfunction: allocate\n\n// Copy the current value of the object instance to the specified instance\nfunction vmm_data $1::copy(vmm_data to=null);\n   transaction_type xactn;\n   if (to != null) begin\n     if (!$cast(xactn, to)) begin\n \\`vmm_fatal(log, \"Not a $1 instance\");\n return null;\n     end\n   end else xactn = new;\n   super.copy_data(xactn);\n\n   \\`vmm_fatal(log, \"$1 Copy function not implemented yet\");\n   // xactn.kind = this.kind;\n   // Copy class members here ...;\n\n   return xactn;\nendfunction: copy\n\nfunction string $1::psdisplay(string prefix = \"\");\n   // $sformat(psdisplay, \"%s$1 %s @ 0x%h = 0h%h\", prefix,\n   //        this.kind.name(), // other variables here\n   //        );\n   \\`vmm_fatal(log, \"$1 psdisplay function not implemented yet\");\nendfunction: psdisplay\n\nfunction bit $1::is_valid(bit silent = 1, int kind = -1);\n   return 1;\nendfunction: is_valid\n\n// compare the values of various elements of the objects\n// Use kind argument to implement partial compare etc.\nfunction bit $1::compare(input vmm_data to, output string diff,\n          input int kind = -1);\n   transaction_type xactn;\n   if(to == null) begin\n      \\`vmm_fatal(log, \"Can not compare to NULL reference\");\n      // return 0; // After fatal, this line would not be reached anyway\n   end // if (to == null)\n   else if (!$cast(xactn, to)) begin\n      \\`vmm_fatal(log, \"Can not copy a non-$1 instance\");\n      // return 0; // After fatal, this line would not be reached anyway\n   end\n   // if (this.kind != xactn.kind) begin\n   //   $sformat(diff, \"Kind %s != %s\", this.kind, xactn.kind);\n   //   return 0;\n   // end\n   // compare other variables here\n   \\`vmm_fatal(log, \"$1 compare function not implemented yet\");\n   return 1;\nendfunction: compare\n\nfunction int unsigned $1::byte_size(input int kind = -1);\n   \\`vmm_fatal(log, \"$1 byte_size function not implemented yet\");\nendfunction: byte_size\n\nfunction int unsigned $1::byte_pack(ref logic[7:0] bytes[],\n                  input int unsigned\n                    offset = 0,\n                   input int kind = -1);\n   \\`vmm_fatal(log, \"$1 byte_pack function not implemented yet\");\nendfunction: byte_pack\n\nfunction int unsigned $1::byte_unpack(const ref logic[7:0] bytes[],\n                      input int unsigned offset = 0,\n                    input int len = -1,\n                   input int kind = -1);\n   \\`vmm_fatal(log, \"$1 byte_unpack function not implemented yet\");\nendfunction: byte_unpack\n\n\n// \\`vmm_atomic_gen($1, \"$1\")\n// \\`vmm_scenario_gen($1, \"$1\")\n" "VMM Transaction (custom)" nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil)
                       ("while" "while (${1:condition}) begin\n   $0\nend // while($1)\n" "while() .." nil nil
                        ((yas/indent-line 'fixed)
                         (yas/wrap-around-region 'nil))
                        nil nil))
                     '(text-mode))
